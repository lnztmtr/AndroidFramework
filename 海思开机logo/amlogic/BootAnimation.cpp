/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#define LOG_TAG "BootAnimation"

#include <stdint.h>
#include <sys/types.h>
#include <math.h>
#include <fcntl.h>
#include <utils/misc.h>
#include <signal.h>

#include <cutils/properties.h>

#include <androidfw/AssetManager.h>
#include <binder/IPCThreadState.h>
#include <utils/Atomic.h>
#include <utils/Errors.h>
#include <utils/Log.h>
#include <utils/threads.h>
#ifdef MOBILE_MIGU_BOOT
#include <utils/misc.h>
#include <utils/Looper.h>
#endif

#include <ui/PixelFormat.h>
#include <ui/Rect.h>
#include <ui/Region.h>
#include <ui/DisplayInfo.h>
#include <ui/FramebufferNativeWindow.h>

#include <gui/ISurfaceComposer.h>
#include <gui/Surface.h>
#include <gui/SurfaceComposerClient.h>

#ifdef MOBILE_MIGU_BOOT
#include <MediaPlayerService.h>
#include <media/mediaplayer.h>
#include <ui/DisplayInfo.h>
#endif

#include <core/SkBitmap.h>
#include <core/SkStream.h>
//#include <images/SkImageDecoder.h>
#include <core/SkCanvas.h>
#include <core/SkScalar.h>
#include <core/SkImageDecoder.h>

#ifdef MOBILE_MIGU_BOOT
#include <android/native_window.h>
#endif

#include <GLES/gl.h>
#include <GLES/glext.h>
#include <EGL/eglext.h>

#include <cutils/properties.h>
#include <libgen.h>

#include "BootAnimation.h"
#include "AlarmTimer.h"
#define USER_BOOTANIMATION_FILE "/data/local/bootanimation.zip"
#define SYSTEM_BOOTANIMATION_FILE "/system/media/bootanimation.zip"
#define SYSTEM_BOOTANIMATION_FILE_720P "/system/media/bootanimation_720.zip"
#define SYSTEM_ENCRYPTED_BOOTANIMATION_FILE "/system/media/bootanimation-encrypted.zip"
#define USER_SHUTDOWN_BOOTANIMATION_FILE  "/data/local/shutdownanimation.zip"
#define SYSTEM_SHUTDOWN_BOOTANIMATION_FILE "/system/media/shutdownanimation.zip"
#define EXIT_PROP_NAME    "service.bootanim.exit"
#define RUNNING_PROP_NAME "svc.bootanim"
#define DISPLAY_EDP_WIDTH		2048
#define DISPLAY_EDP_HEIGHT		1536

#ifdef MOBILE_MIGU_BOOT
#define IPTV_ANIMATION_CONFIG_FILE "configs.txt"
#define IPTV_ANIMATION_CONFIG_BASE "/data/local/"
#define IPTV_ANIMATION_SYSTEM_BASE "/system/media/"
#endif
extern "C" int clock_nanosleep(clockid_t clock_id, int flags,
                           const struct timespec *request,
                           struct timespec *remain);

extern bool gUseBootVideo ;
extern bool gUseBootAdv;
extern int gVideoAnimationFlag;

#ifdef MOBILE_MIGU_BOOT
static char gCountDownPng[] =  {
0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52,
0x00, 0x00, 0x00, 0xBC, 0x00, 0x00, 0x00, 0x46, 0x08, 0x06, 0x00, 0x00, 0x01, 0x01, 0x47, 0xCE,
0x42, 0x00, 0x00, 0x00, 0x01, 0x73, 0x52, 0x47, 0x42, 0x00, 0xAE, 0xCE, 0x1C, 0xE9, 0x00, 0x00,
0x16, 0xE5, 0x49, 0x44, 0x41, 0x54, 0x78, 0x01, 0xED, 0x9D, 0x09, 0x98, 0x16, 0xC5, 0x99, 0xC7,
0x61, 0x86, 0x19, 0x6E, 0x50, 0x50, 0xAE, 0xAC, 0xC1, 0x88, 0x22, 0xC7, 0x06, 0x14, 0x35, 0x1E,
0xBB, 0xA8, 0x28, 0x89, 0xF1, 0x8A, 0x8B, 0x78, 0x80, 0xFA, 0xAC, 0x82, 0x51, 0xB3, 0xB2, 0xBA,
0x62, 0xB2, 0xE2, 0x6D, 0x12, 0x15, 0x81, 0xDD, 0xAC, 0x6E, 0x30, 0x26, 0x06, 0x12, 0x49, 0x4C,
0x0C, 0x46, 0x23, 0x41, 0x8D, 0x78, 0x63, 0xD0, 0x6C, 0x92, 0x95, 0x1C, 0x6B, 0x40, 0x21, 0x2E,
0xF1, 0x62, 0xC5, 0x21, 0x0A, 0x32, 0xDC, 0x03, 0x33, 0xE4, 0xF7, 0x6F, 0xFA, 0x6D, 0xEA, 0xEB,
0xE3, 0xEB, 0x9E, 0x6F, 0x40, 0xC8, 0x3E, 0x55, 0xCF, 0x53, 0x53, 0x55, 0xEF, 0x55, 0x6F, 0xFD,
0xEB, 0xED, 0xEA, 0xEA, 0xFE, 0xBA, 0x7B, 0x5A, 0xB5, 0xF2, 0xA9, 0x08, 0x02, 0xF5, 0xF5, 0xF5,
0xA3, 0xE2, 0x72, 0xD0, 0x4E, 0x5B, 0xB3, 0x66, 0xCD, 0x41, 0xCA, 0x2E, 0x6F, 0xDD, 0xBA, 0x75,
0x27, 0x59, 0x1B, 0xDE, 0x36, 0xE5, 0xB5, 0x6B, 0xD7, 0xF6, 0x50, 0x69, 0x74, 0x95, 0xD6, 0x6E,
0x13, 0x12, 0xBB, 0xBB, 0xCC, 0xB0, 0x3E, 0xBC, 0x75, 0xEB, 0xD6, 0xC3, 0x55, 0xA7, 0xB3, 0x56,
0x5D, 0xBA, 0x74, 0x99, 0xA4, 0x7A, 0xA7, 0x4E, 0x9D, 0x9E, 0xDA, 0xB6, 0x6D, 0x5B, 0x15, 0xBC,
0x26, 0xB5, 0x49, 0xF5, 0xDB, 0x8B, 0xD2, 0xBF, 0x5D, 0xBB, 0x76, 0x6D, 0x1D, 0x51, 0xAC, 0xB7,
0x88, 0x40, 0x25, 0x8D, 0xE6, 0xF2, 0x55, 0x97, 0x8C, 0xB2, 0x3B, 0x02, 0x3A, 0x0F, 0x0C, 0xE3,
0xD4, 0xE9, 0x91, 0xFC, 0xFA, 0xF5, 0xEB, 0x0F, 0x8D, 0x1A, 0x61, 0x25, 0xDE, 0x01, 0x0A, 0xFF,
0x27, 0x96, 0x4A, 0x78, 0x6B, 0xE3, 0xF2, 0xD0, 0x2F, 0x16, 0x2D, 0xAE, 0x17, 0x97, 0xF3, 0xED,
0xDD, 0x80, 0x00, 0x11, 0x70, 0x45, 0x25, 0xDD, 0xA2, 0x37, 0xC8, 0xD5, 0x23, 0x7A, 0x6A, 0xDC,
0x76, 0xA2, 0x4E, 0x14, 0x9C, 0x41, 0x04, 0x04, 0x07, 0x96, 0x4A, 0x09, 0x10, 0x5D, 0x87, 0xB9,
0x82, 0x8A, 0x10, 0xCB, 0x46, 0x57, 0x5B, 0x75, 0xCA, 0x53, 0x54, 0xEE, 0x08, 0x7E, 0xB5, 0xC2,
0x84, 0xF1, 0xA9, 0x56, 0x57, 0xA9, 0x83, 0xCA, 0x14, 0x75, 0xC0, 0x50, 0xBF, 0x80, 0xF2, 0x07,
0xA2, 0x95, 0x1C, 0x40, 0xAE, 0x52, 0x91, 0xBA, 0x19, 0xB5, 0xD2, 0xD5, 0x89, 0xD3, 0x80, 0x68,
0x84, 0xF8, 0x38, 0x77, 0xB0, 0x2B, 0x97, 0x59, 0x77, 0x0D, 0x50, 0x9F, 0x47, 0xFE, 0x90, 0x1C,
0x1C, 0x50, 0xC6, 0xB3, 0x52, 0x46, 0xDC, 0x7A, 0xA6, 0x51, 0xCF, 0xF0, 0x08, 0x64, 0x20, 0x10,
0x1D, 0x4A, 0x9C, 0xDC, 0x0E, 0x69, 0x6A, 0x6A, 0xFA, 0x82, 0xC9, 0x71, 0x30, 0x9F, 0xCD, 0x79,
0xE8, 0x21, 0x6B, 0x73, 0x38, 0x05, 0x3C, 0x22, 0xB9, 0x91, 0x7A, 0xB5, 0xD1, 0xE3, 0x25, 0x11,
0x3F, 0x1A, 0xDD, 0x61, 0xE4, 0xAE, 0xF0, 0x26, 0xC4, 0xF9, 0xE1, 0xA1, 0x38, 0x1B, 0xDB, 0xCB,
0x90, 0xB9, 0xDE, 0x0E, 0x45, 0xEA, 0x6D, 0xA0, 0x6D, 0x55, 0x40, 0x1B, 0x4D, 0xBA, 0xB4, 0x7F,
0x04, 0xFD, 0x69, 0xAA, 0x53, 0x3A, 0x77, 0xEE, 0x3C, 0x90, 0xFA, 0xAA, 0xB8, 0x4D, 0x1D, 0x5E,
0x89, 0xB3, 0x78, 0x5C, 0x08, 0x99, 0xF1, 0x71, 0x5A, 0x5E, 0x1B, 0x9D, 0x8D, 0x92, 0xA1, 0xB4,
0x13, 0x72, 0xA0, 0x22, 0x27, 0xC3, 0xBC, 0x66, 0xE3, 0xC6, 0x8D, 0x7D, 0x19, 0x74, 0x0F, 0x31,
0x44, 0x53, 0x89, 0xFC, 0x45, 0xD4, 0xFF, 0x85, 0xBC, 0xCC, 0xCD, 0xA1, 0xCC, 0xB3, 0x2A, 0x23,
0xE4, 0x11, 0xFE, 0x0E, 0x88, 0x06, 0xE7, 0x47, 0x31, 0xB2, 0x12, 0x72, 0x73, 0xD2, 0x78, 0xE8,
0x46, 0x83, 0x0F, 0x1D, 0x78, 0x10, 0x04, 0xC7, 0xB8, 0xB2, 0xD0, 0x9F, 0x84, 0xF6, 0x59, 0x6C,
0x34, 0x80, 0x74, 0xB0, 0x4C, 0x83, 0xE4, 0x1D, 0xD4, 0xAF, 0xAB, 0xAA, 0xAA, 0xEA, 0x09, 0xB2,
0x2B, 0xA5, 0x2B, 0xE4, 0xA1, 0xB5, 0x75, 0x75, 0x63, 0xF5, 0x46, 0xCD, 0x52, 0x44, 0x0B, 0x3B,
0x8C, 0xDA, 0x59, 0x95, 0x34, 0x39, 0x97, 0x06, 0x82, 0xC7, 0xD1, 0x7E, 0x99, 0xCE, 0x3B, 0xE4,
0xD9, 0x30, 0x3D, 0x2B, 0x25, 0x6F, 0x75, 0xC2, 0x58, 0x83, 0x7C, 0x38, 0x6E, 0x43, 0xF6, 0xC9,
0x03, 0xE3, 0x74, 0xDF, 0xF6, 0x08, 0x78, 0x04, 0x3C, 0x02, 0x1E, 0x81, 0xE2, 0x08, 0xB0, 0xD6,
0xFE, 0x29, 0x4F, 0x9A, 0x35, 0xF8, 0xEA, 0x3C, 0x99, 0x22, 0x7C, 0xCE, 0x07, 0xD1, 0x89, 0x32,
0x4B, 0x9E, 0x35, 0x7F, 0x64, 0x1A, 0x2F, 0x52, 0xC4, 0x99, 0x6F, 0x39, 0x02, 0x97, 0x52, 0xFF,
0xB6, 0xB5, 0x39, 0xF3, 0x4D, 0xE0, 0x8C, 0xD6, 0xA8, 0x36, 0x27, 0x88, 0xBB, 0x68, 0x5F, 0xA5,
0x93, 0x89, 0xBB, 0x07, 0x31, 0x59, 0xA3, 0xDB, 0xC9, 0xC6, 0xE8, 0x2A, 0x4D, 0x9E, 0xBE, 0xEE,
0xA5, 0xB9, 0xB4, 0xBA, 0xBA, 0x7A, 0x76, 0xC7, 0x8E, 0x1D, 0xDF, 0x15, 0x4F, 0xD7, 0x38, 0xEC,
0xAD, 0xF6, 0xC7, 0xF6, 0x4F, 0xD4, 0xB6, 0xE4, 0xDA, 0x33, 0x7D, 0xE3, 0x45, 0xCE, 0x9B, 0x90,
0x31, 0xD2, 0xCA, 0xD0, 0xA1, 0xFE, 0x21, 0xEF, 0x8F, 0x94, 0x56, 0x97, 0x63, 0xAF, 0x67, 0xE9,
0xB8, 0x9D, 0x82, 0xE2, 0x89, 0x8D, 0x8D, 0x8D, 0xC1, 0xDE, 0xC4, 0xE4, 0xD9, 0x5A, 0x74, 0x63,
0x40, 0xAB, 0xD8, 0x22, 0x9C, 0x65, 0xCE, 0xD3, 0xD7, 0xEF, 0xE0, 0xF7, 0x45, 0xB7, 0x9B, 0xC9,
0xA9, 0x7F, 0x40, 0xBC, 0x08, 0xF9, 0xEF, 0x19, 0x2D, 0x28, 0x43, 0xC7, 0x4A, 0x68, 0xE5, 0x1A,
0x45, 0xE4, 0x71, 0xA8, 0x4E, 0x72, 0x94, 0x8B, 0x5C, 0x5B, 0x84, 0x4A, 0x67, 0x6B, 0xC3, 0x3F,
0x39, 0xCC, 0xBA, 0xC1, 0x31, 0x5A, 0x74, 0xE4, 0xDF, 0x53, 0x09, 0xDD, 0x36, 0x65, 0xDA, 0xC4,
0x05, 0x75, 0xD1, 0x2D, 0x15, 0x46, 0x1E, 0x83, 0x25, 0x57, 0x9C, 0x66, 0xC0, 0x4A, 0x1C, 0x9A,
0xE9, 0xA2, 0x8F, 0xFC, 0xAB, 0xA0, 0x38, 0x94, 0xB2, 0x41, 0xC8, 0xD3, 0x79, 0x14, 0x66, 0x72,
0x1E, 0x04, 0xED, 0x3A, 0xEF, 0x64, 0xF8, 0xBA, 0xF6, 0xDB, 0xE6, 0x22, 0x6F, 0x76, 0x55, 0xBA,
0xBA, 0x2E, 0xBD, 0xCA, 0x6D, 0x94, 0xAB, 0x33, 0x55, 0x93, 0xE8, 0x54, 0x77, 0x6D, 0x14, 0x2A,
0x25, 0x59, 0x3C, 0xD7, 0x71, 0xD9, 0x81, 0x36, 0x08, 0x07, 0xB7, 0xA8, 0xAE, 0xA4, 0x01, 0xA8,
0xC4, 0x91, 0x07, 0x36, 0x6D, 0xDA, 0xB4, 0xF7, 0x86, 0x0D, 0x1B, 0x3E, 0xA6, 0x36, 0xE9, 0x09,
0x06, 0xF8, 0xB5, 0xED, 0xD5, 0x1D, 0xBB, 0x5C, 0xFA, 0x6A, 0x6B, 0x59, 0x3C, 0xAB, 0xAB, 0x0C,
0x65, 0x77, 0x14, 0x18, 0xB8, 0x76, 0x47, 0x2B, 0xBD, 0x86, 0xCC, 0xAC, 0x74, 0x4E, 0x36, 0x55,
0xA8, 0xA5, 0x71, 0xB1, 0x35, 0x15, 0xDE, 0x74, 0x42, 0x65, 0xB0, 0xF8, 0x92, 0xB3, 0xB0, 0x31,
0x79, 0xD3, 0x8D, 0x97, 0xC6, 0x0F, 0x4A, 0x90, 0xE8, 0x57, 0x42, 0xC8, 0x68, 0x14, 0x71, 0x5E,
0x1D, 0x59, 0x67, 0x32, 0x83, 0x43, 0x77, 0xBA, 0xE6, 0x68, 0xDF, 0x88, 0x9D, 0x9F, 0x19, 0xCD,
0x9C, 0x0F, 0x65, 0x83, 0x98, 0x57, 0xDD, 0xB5, 0x91, 0x55, 0x0F, 0x6C, 0xC0, 0xD4, 0x91, 0x9D,
0x9B, 0xF2, 0x9C, 0x67, 0x25, 0x19, 0x62, 0x46, 0x70, 0xEA, 0x32, 0xE4, 0x5F, 0x23, 0xEB, 0x02,
0x63, 0xAD, 0xB2, 0xF1, 0xD2, 0x4A, 0xE4, 0x1E, 0x73, 0x9D, 0x34, 0x19, 0xD1, 0xB0, 0x15, 0x0D,
0xCA, 0xE8, 0xBE, 0xF4, 0x08, 0x78, 0x04, 0x3C, 0x02, 0x1E, 0x01, 0x8F, 0x80, 0x47, 0xC0, 0x23,
0xE0, 0x11, 0xD8, 0x43, 0x10, 0x88, 0xAE, 0xA2, 0xF2, 0xFC, 0xE1, 0x02, 0xA0, 0x96, 0x5D, 0xDF,
0x66, 0xAE, 0x74, 0x7A, 0x70, 0x75, 0xF4, 0xE7, 0x3C, 0x79, 0xE3, 0xEB, 0x4E, 0x2F, 0xD7, 0xAB,
0xF3, 0xEC, 0x42, 0x44, 0x74, 0xED, 0x12, 0xDD, 0xB6, 0xC9, 0xC6, 0x4B, 0xFA, 0xEC, 0x48, 0x9F,
0xEB, 0xE8, 0xF3, 0x04, 0xFA, 0x9C, 0x2F, 0x3E, 0xF6, 0x3E, 0xCD, 0x45, 0xFA, 0xB0, 0xB8, 0x6C,
0x5A, 0x9B, 0x8B, 0xA1, 0xE8, 0xCA, 0x0F, 0x3B, 0xFF, 0x8A, 0x3D, 0x5D, 0x7A, 0xEE, 0x45, 0xD6,
0x0F, 0x14, 0x83, 0x69, 0xF7, 0x76, 0xF4, 0x56, 0xE1, 0x53, 0x77, 0xA7, 0xAD, 0xAD, 0xFC, 0x68,
0xFA, 0x7A, 0x38, 0xCF, 0x57, 0xE4, 0x8E, 0x45, 0xEE, 0xE7, 0xA1, 0x6E, 0xC2, 0x8E, 0x6B, 0xD3,
0xEA, 0x09, 0xE0, 0x71, 0x70, 0x14, 0x0E, 0x3D, 0x82, 0x63, 0xCB, 0x4D, 0xA8, 0x68, 0x09, 0x38,
0x9F, 0x40, 0x2F, 0xBA, 0xDF, 0x0F, 0xC0, 0x57, 0xA2, 0xFB, 0x9F, 0x45, 0xF5, 0x25, 0x97, 0x36,
0x48, 0x7C, 0x1A, 0x80, 0x4F, 0xAF, 0x31, 0x01, 0x37, 0xD1, 0xC7, 0x6D, 0x71, 0x7B, 0x9A, 0x48,
0x78, 0x97, 0xC1, 0x8B, 0xEE, 0xD4, 0xC4, 0x65, 0xE2, 0xED, 0xAC, 0xC9, 0x07, 0xC4, 0x1E, 0x80,
0x58, 0x27, 0x3F, 0xCA, 0x01, 0x8F, 0x3F, 0x35, 0xF8, 0xA5, 0x00, 0xEC, 0xCA, 0xDD, 0x9B, 0xA1,
0x3C, 0x8D, 0xF1, 0x8A, 0xF5, 0x81, 0xED, 0x1F, 0x51, 0x1F, 0x03, 0x16, 0x93, 0x98, 0xFC, 0x69,
0x46, 0x77, 0x4B, 0x7B, 0xDC, 0xC3, 0xA5, 0x05, 0x75, 0x14, 0xF6, 0x4B, 0x10, 0x0B, 0x12, 0x70,
0xA8, 0x3F, 0x8E, 0x2D, 0x05, 0x8C, 0xD1, 0x80, 0x91, 0x98, 0xDC, 0xAC, 0x41, 0x67, 0x99, 0xC7,
0x97, 0x25, 0xF0, 0x12, 0x76, 0x24, 0x2F, 0x5B, 0xA1, 0xDE, 0x4F, 0x55, 0x47, 0x56, 0x8F, 0xA2,
0x18, 0x2D, 0x64, 0xED, 0x9C, 0x82, 0x71, 0xFD, 0x94, 0x71, 0x9D, 0x21, 0x6B, 0x4C, 0xCA, 0xBF,
0xD3, 0xCF, 0x23, 0xAA, 0x33, 0x51, 0x57, 0xC1, 0x53, 0xD5, 0x92, 0x7E, 0x81, 0xBB, 0x8F, 0x3C,
0x00, 0x9F, 0xEE, 0xA6, 0x0C, 0x7E, 0x52, 0x04, 0x8F, 0x11, 0xE0, 0xF1, 0x02, 0xED, 0x56, 0x09,
0xE0, 0x31, 0xA6, 0x5F, 0xB1, 0xC4, 0xAB, 0x38, 0x09, 0x74, 0x29, 0xE3, 0xD0, 0x4F, 0xE8, 0x38,
0xD5, 0x8E, 0x03, 0x58, 0x82, 0x4F, 0x04, 0x7D, 0x86, 0x08, 0x7A, 0x06, 0x99, 0xDF, 0xC0, 0x8C,
0x96, 0x15, 0xF7, 0x68, 0x60, 0xA0, 0xAF, 0xD0, 0xCF, 0x27, 0x45, 0x93, 0x2D, 0x06, 0xB4, 0x12,
0xD9, 0xD6, 0xD0, 0x9B, 0x68, 0xBF, 0x09, 0xFD, 0x00, 0x33, 0x4C, 0xFB, 0x1E, 0xEA, 0xFF, 0x64,
0x6D, 0xD7, 0x0E, 0x3C, 0x39, 0xD8, 0x85, 0x61, 0xEB, 0x3E, 0xA6, 0x64, 0xE6, 0x9A, 0x5C, 0xBC,
0x64, 0x52, 0xFF, 0x21, 0x4E, 0x73, 0xDB, 0x98, 0xCA, 0x5A, 0x42, 0xFF, 0xD9, 0x95, 0x53, 0x3D,
0x01, 0x3C, 0xB4, 0x41, 0x71, 0xA1, 0xE6, 0xB6, 0xDD, 0x81, 0x35, 0x57, 0xD7, 0x95, 0xC7, 0xCE,
0x61, 0xD6, 0xD6, 0xA0, 0x54, 0x07, 0xD8, 0x46, 0x00, 0xAF, 0x02, 0x68, 0xFD, 0xD8, 0x1C, 0xDC,
0xF4, 0x35, 0x19, 0x95, 0x8A, 0x78, 0x64, 0xAF, 0x94, 0xBC, 0x45, 0x3F, 0x76, 0x2E, 0xE7, 0x06,
0xEE, 0x7D, 0x9C, 0x6B, 0x7E, 0x89, 0x6E, 0xDA, 0x0F, 0xDF, 0xA7, 0x22, 0xAB, 0x9B, 0x5E, 0xB2,
0xE7, 0x02, 0x9F, 0x38, 0xCA, 0xCC, 0x0F, 0xB7, 0x4F, 0xB7, 0x9E, 0xC5, 0xC7, 0xD7, 0xB9, 0xEE,
0xC4, 0x25, 0x80, 0x27, 0x4A, 0x2F, 0x45, 0x68, 0x81, 0x6B, 0xAC, 0xD2, 0x3A, 0x03, 0x99, 0xC5,
0x40, 0x2F, 0x44, 0x5F, 0x91, 0x9B, 0x97, 0x0E, 0x2B, 0x32, 0x61, 0x38, 0x9F, 0x06, 0x5C, 0x89,
0x6D, 0xEC, 0x7C, 0x1D, 0x82, 0x72, 0x90, 0xF0, 0x81, 0x21, 0xB5, 0x7E, 0x99, 0x46, 0x1B, 0xD5,
0x0D, 0x1C, 0xFC, 0x5B, 0x89, 0xBD, 0xAE, 0xA1, 0x98, 0x26, 0xAD, 0x5A, 0x6B, 0xBC, 0xB5, 0x29,
0x13, 0x87, 0xBE, 0xEB, 0x23, 0xFA, 0x5A, 0xC3, 0xA3, 0x13, 0xB8, 0xEC, 0x1A, 0x1F, 0x3B, 0x97,
0xA1, 0xFF, 0x3A, 0x01, 0xF2, 0xBC, 0x63, 0x2F, 0xBB, 0x2A, 0xE5, 0x58, 0xE7, 0xD9, 0xC2, 0x39,
0x1C, 0x01, 0x6F, 0x83, 0xCC, 0x11, 0x75, 0xD7, 0xEA, 0x84, 0xA8, 0x9E, 0x48, 0x90, 0x1D, 0x52,
0x22, 0x50, 0x24, 0x5C, 0xA4, 0x0F, 0x76, 0x43, 0xBD, 0x24, 0x87, 0x4F, 0x3F, 0x77, 0x75, 0xA0,
0x8F, 0x0C, 0xE9, 0xB7, 0x8B, 0x4E, 0x1F, 0x7B, 0x23, 0x13, 0x04, 0x1E, 0x38, 0x8C, 0x4E, 0xB3,
0x2D, 0x3F, 0x42, 0x9D, 0xD3, 0xA4, 0x63, 0x29, 0x2E, 0x8B, 0xFE, 0x60, 0xD1, 0x64, 0xC7, 0x64,
0xAC, 0x2C, 0x19, 0x08, 0x1D, 0xBE, 0x83, 0xD1, 0xB5, 0xE1, 0x7A, 0x69, 0x32, 0x2D, 0x2E, 0xE3,
0x0E, 0x15, 0x35, 0x88, 0x2F, 0x55, 0xF8, 0xD4, 0xB8, 0x75, 0xEB, 0xD6, 0x73, 0x15, 0x49, 0x0C,
0x60, 0x04, 0xB6, 0x9E, 0x27, 0x7A, 0xF5, 0xB4, 0xC5, 0x1C, 0x4E, 0x56, 0xAF, 0x52, 0x6E, 0x24,
0x4F, 0x84, 0x77, 0x05, 0x47, 0xAB, 0x96, 0x1F, 0xDD, 0x0F, 0x6F, 0x47, 0xD9, 0x19, 0xFE, 0xFD,
0x9C, 0x2B, 0x7E, 0x0F, 0xEF, 0x1C, 0x68, 0x55, 0x16, 0x8D, 0x6E, 0xFF, 0xF0, 0xF5, 0xD3, 0x4C,
0xB4, 0xA4, 0xA0, 0xB7, 0x1A, 0xD9, 0xCF, 0x48, 0x86, 0xF2, 0x7C, 0x57, 0x16, 0x3B, 0x83, 0xE9,
0x63, 0x11, 0xCB, 0x96, 0x7E, 0x48, 0x08, 0x74, 0xF0, 0xEF, 0x68, 0x64, 0x56, 0x21, 0x3B, 0xDD,
0x95, 0x55, 0x1D, 0x1C, 0x17, 0x53, 0xC8, 0xEF, 0x3B, 0xF1, 0x3B, 0x77, 0x5B, 0x1A, 0xD7, 0xF7,
0x6D, 0x8F, 0x80, 0x47, 0xC0, 0x23, 0xE0, 0x11, 0xF0, 0x08, 0x78, 0x04, 0x3C, 0x02, 0x1E, 0x01,
0x8F, 0x80, 0x47, 0xC0, 0x23, 0xE0, 0x11, 0xF0, 0x08, 0x78, 0x04, 0x3C, 0x02, 0x1E, 0x01, 0x8F,
0x80, 0x47, 0x40, 0x08, 0x70, 0x17, 0xEE, 0x51, 0x72, 0xF4, 0x70, 0x76, 0xA5, 0xA8, 0x60, 0xE3,
0x62, 0xEE, 0xD6, 0x9D, 0x5B, 0xA9, 0xFE, 0xAE, 0xD0, 0xD3, 0x5D, 0xC7, 0x96, 0xDA, 0xE5, 0xF6,
0xF2, 0x89, 0xDC, 0xA1, 0x4C, 0x3E, 0x11, 0x9C, 0x61, 0x38, 0xBA, 0x1D, 0x9A, 0xC1, 0x8F, 0xC8,
0xDC, 0xD6, 0x7C, 0x8B, 0x5B, 0xA6, 0x3D, 0xB8, 0xF1, 0xDF, 0x3E, 0x22, 0x16, 0xA8, 0xE8, 0x96,
0x30, 0x7A, 0x97, 0xA0, 0x37, 0x53, 0xE2, 0xB4, 0x97, 0xD1, 0x7E, 0x97, 0xF6, 0xF0, 0x3C, 0x75,
0x64, 0x7F, 0x8D, 0x6C, 0x3F, 0x64, 0xF7, 0x31, 0x59, 0x26, 0x6E, 0x92, 0xD5, 0xCB, 0x95, 0xDC,
0x12, 0x9E, 0xC5, 0x2D, 0xDF, 0x3A, 0xC9, 0xA0, 0x73, 0x34, 0x76, 0x4E, 0x00, 0x98, 0xCE, 0xE4,
0x8F, 0x53, 0xD7, 0xAF, 0x6C, 0x43, 0xA8, 0xBB, 0xE3, 0x3F, 0x85, 0x5B, 0xBD, 0xF3, 0x5C, 0x9B,
0xF2, 0xBD, 0x4D, 0x9B, 0x36, 0xC3, 0x78, 0x0D, 0xA1, 0xEC, 0x73, 0xBD, 0xD8, 0x7F, 0x0F, 0x5B,
0x3D, 0x43, 0xDD, 0x84, 0x1D, 0xD7, 0xA6, 0xD5, 0x4B, 0xEE, 0xC7, 0x8B, 0x88, 0x11, 0xF7, 0x1D,
0x0B, 0x93, 0x53, 0xF9, 0x2C, 0xC6, 0xC7, 0x97, 0xE1, 0xEB, 0x17, 0x9C, 0xE8, 0xBD, 0x53, 0x29,
0xE8, 0x7D, 0x09, 0xEE, 0xA5, 0x8B, 0x1E, 0x80, 0x2E, 0x5A, 0x73, 0x12, 0x40, 0x1C, 0xC9, 0xE0,
0xD7, 0x0B, 0x00, 0xBB, 0xFF, 0x8D, 0x0F, 0x53, 0x8A, 0xD8, 0x00, 0x5C, 0xBD, 0x6B, 0x1A, 0x00,
0xCF, 0x7D, 0xF1, 0x85, 0x44, 0xF5, 0xE5, 0xD0, 0xDE, 0x27, 0x2F, 0xC6, 0x46, 0x27, 0x78, 0x03,
0xB1, 0x99, 0x88, 0x50, 0xF9, 0xDC, 0xA1, 0x43, 0x87, 0xA5, 0xC8, 0xAD, 0xCB, 0xEB, 0x07, 0x3B,
0xC1, 0xE3, 0x27, 0xC8, 0x35, 0xCA, 0x3F, 0xB0, 0x19, 0x0E, 0x6D, 0x01, 0xFE, 0xEA, 0x2D, 0xCD,
0x93, 0xCB, 0xE9, 0xBB, 0x33, 0x1E, 0xC8, 0x69, 0x90, 0x54, 0x56, 0xD1, 0xF1, 0x86, 0x72, 0x8A,
0x69, 0x3C, 0x00, 0xDE, 0xCF, 0xA5, 0x87, 0xB6, 0x5C, 0x52, 0xD9, 0x3A, 0x7D, 0x4E, 0xC3, 0x46,
0x22, 0xA2, 0x19, 0x50, 0x1D, 0x03, 0xEA, 0x61, 0xE0, 0xBB, 0x46, 0xE8, 0x43, 0x03, 0x7C, 0x22,
0x8D, 0xE7, 0xCA, 0xB9, 0x75, 0xEC, 0x5D, 0x4F, 0xFB, 0x26, 0xFA, 0x6A, 0xEF, 0xD2, 0x55, 0x97,
0xCF, 0xF6, 0x34, 0x80, 0xEA, 0x59, 0x11, 0xAF, 0x89, 0xE4, 0x47, 0x91, 0x6F, 0xE0, 0xF3, 0x52,
0xEC, 0x0C, 0x30, 0x3B, 0xF8, 0xD9, 0x1E, 0xFB, 0x1B, 0xA0, 0x6F, 0x66, 0xC2, 0xF7, 0xA6, 0xDC,
0x68, 0x3C, 0xB7, 0x4C, 0x44, 0xBC, 0x98, 0x74, 0x3C, 0x01, 0xA5, 0xD9, 0xAE, 0x60, 0x73, 0xEB,
0x74, 0xBE, 0x05, 0x27, 0x34, 0x79, 0x87, 0xC4, 0x74, 0x9F, 0xA3, 0xAD, 0x27, 0x02, 0xC6, 0xC6,
0xE8, 0x6A, 0xAE, 0x4E, 0xA1, 0xE9, 0x88, 0xE9, 0xC9, 0xCF, 0x7F, 0x9F, 0x48, 0xE3, 0x41, 0x7B,
0x82, 0xC1, 0x3D, 0x94, 0xC1, 0x0B, 0xC8, 0xF1, 0x00, 0xC0, 0xAF, 0x54, 0x7A, 0x91, 0xC9, 0xB3,
0x89, 0x06, 0x74, 0xD9, 0xB8, 0x10, 0xDF, 0xBE, 0x1F, 0x18, 0x0B, 0xFF, 0x84, 0x40, 0x2B, 0xFA,
0xEB, 0x34, 0x01, 0xC8, 0xBF, 0x81, 0xCC, 0x41, 0xD0, 0xF5, 0x43, 0x7A, 0x94, 0x52, 0x81, 0x8F,
0xB8, 0x15, 0x56, 0xE8, 0x4C, 0x87, 0x69, 0x6B, 0x06, 0xD2, 0x31, 0x6E, 0x02, 0xDE, 0x16, 0x39,
0x87, 0x33, 0xA9, 0x6F, 0x4E, 0xC5, 0xE5, 0xAD, 0xDD, 0xBE, 0x7D, 0xFB, 0x37, 0xAC, 0x6E, 0x25,
0xB6, 0xBE, 0xA9, 0x3A, 0x40, 0x36, 0x32, 0xC8, 0xD7, 0xA8, 0xBE, 0x8A, 0xDD, 0xC4, 0xEF, 0x9B,
0x71, 0x40, 0x91, 0xCD, 0x8C, 0x78, 0xB3, 0x1D, 0x2F, 0x89, 0xF0, 0x41, 0x80, 0xAD, 0x9F, 0xF2,
0x5A, 0xE1, 0xFF, 0x2B, 0x14, 0xFA, 0x01, 0xFF, 0x78, 0x6C, 0x1D, 0x4F, 0x99, 0x96, 0x7E, 0x86,
0x9C, 0x1E, 0x73, 0xB9, 0x15, 0x19, 0xBD, 0x7A, 0xFF, 0x7B, 0xFC, 0x38, 0xD4, 0x04, 0x77, 0x09,
0xF0, 0x1C, 0x9E, 0xFD, 0xED, 0xBD, 0x38, 0xEB, 0x68, 0x67, 0x97, 0xBC, 0x8B, 0xB4, 0xDF, 0x96,
0x2D, 0x5B, 0xBE, 0xC0, 0xE0, 0xB6, 0x2A, 0x82, 0x39, 0x42, 0x8F, 0x60, 0x80, 0x6B, 0xC9, 0xA3,
0x00, 0x7F, 0x4E, 0x5A, 0x7F, 0x0C, 0x5E, 0xA1, 0x7E, 0x94, 0xCB, 0x13, 0x4D, 0x13, 0x83, 0xDE,
0x64, 0xF4, 0x34, 0x21, 0xA9, 0x89, 0x13, 0xF5, 0xDB, 0xC8, 0x2C, 0x43, 0x66, 0x80, 0xFA, 0x44,
0x6F, 0x99, 0x2B, 0x08, 0x6D, 0x7F, 0xFC, 0x58, 0x0F, 0xED, 0xCF, 0x46, 0x87, 0x56, 0x87, 0x7C,
0x6D, 0x78, 0xAE, 0x2B, 0x39, 0x37, 0xED, 0x74, 0xE0, 0xF5, 0x6C, 0x23, 0x27, 0xD4, 0xA7, 0x71,
0xCC, 0xFA, 0x4F, 0x94, 0x38, 0x78, 0x40, 0x08, 0x42, 0x82, 0x27, 0x82, 0x45, 0xA8, 0x2B, 0xC3,
0x20, 0x16, 0x30, 0x88, 0xE3, 0xC4, 0x47, 0xBF, 0x1B, 0x20, 0xBC, 0x0D, 0xED, 0x06, 0xEA, 0xD7,
0x88, 0x44, 0x7D, 0x1D, 0xB4, 0xD3, 0x69, 0x3F, 0x46, 0xEE, 0x4E, 0x3B, 0xFA, 0x78, 0x83, 0x6B,
0x47, 0xFA, 0xF1, 0x14, 0xF2, 0xE7, 0xC7, 0xE9, 0x6E, 0x5B, 0xF6, 0x69, 0x1F, 0x68, 0x34, 0x7C,
0x2C, 0x79, 0xFD, 0x0A, 0x1B, 0xAB, 0x91, 0x99, 0x83, 0x8F, 0xE3, 0x4D, 0xC6, 0x4A, 0x82, 0x50,
0x47, 0xC7, 0xA7, 0xAD, 0xAD, 0x32, 0x0B, 0x78, 0xAD, 0xC1, 0x15, 0x25, 0x1E, 0x1A, 0x7A, 0x13,
0x07, 0xA6, 0x55, 0xA4, 0x1C, 0x53, 0x72, 0x26, 0x40, 0xCF, 0x22, 0xF6, 0x11, 0x1B, 0x70, 0xFB,
0x93, 0xB5, 0xEB, 0x78, 0x81, 0x41, 0x4E, 0x66, 0xC0, 0x02, 0x3E, 0x48, 0xB4, 0x1F, 0x87, 0xF7,
0x22, 0xF9, 0x03, 0x08, 0xD1, 0xC6, 0xC1, 0xB1, 0xA3, 0x88, 0x4F, 0x24, 0xF1, 0x89, 0xCA, 0xDE,
0x09, 0xC6, 0x2E, 0x24, 0xA4, 0x02, 0xCF, 0x5A, 0xF6, 0x4E, 0xA5, 0x7D, 0x32, 0x08, 0xAD, 0xDD,
0x89, 0x9D, 0x49, 0xA5, 0xF6, 0x5C, 0x3D, 0x00, 0xBD, 0x96, 0x68, 0xBE, 0x03, 0xDA, 0x37, 0x01,
0xF9, 0x72, 0x97, 0x67, 0x75, 0xE8, 0xC7, 0x2A, 0x82, 0x91, 0x7D, 0x9E, 0xFA, 0x09, 0x46, 0x87,
0x56, 0x76, 0xB3, 0xC0, 0x51, 0xFA, 0x0B, 0x6C, 0x0F, 0x44, 0xCF, 0x54, 0x12, 0x25, 0x36, 0x1E,
0x80, 0x98, 0xB6, 0x29, 0x08, 0x64, 0xD1, 0x1F, 0x87, 0xCC, 0xB8, 0x84, 0x22, 0x04, 0x9B, 0x7C,
0xE3, 0xA5, 0x02, 0x8F, 0xC3, 0x15, 0x03, 0x6F, 0x86, 0x55, 0x32, 0x88, 0xD4, 0xB5, 0xD6, 0x95,
0xB1, 0x3A, 0x4E, 0x2F, 0xC7, 0xB9, 0x2B, 0xAC, 0x9D, 0x56, 0xB2, 0x8E, 0x4F, 0xE5, 0x24, 0xB7,
0x18, 0xFF, 0x1E, 0x4B, 0xE3, 0x1B, 0xAD, 0x6D, 0xDB, 0xB6, 0xFD, 0xB0, 0x17, 0x45, 0xB7, 0x26,
0x82, 0x9D, 0xDA, 0x5D, 0xE1, 0x4E, 0x44, 0x62, 0x13, 0x4C, 0x56, 0xA5, 0xF8, 0x2A, 0x39, 0x8A,
0x36, 0x53, 0x57, 0x35, 0x35, 0xD1, 0xEF, 0x3F, 0xC2, 0x48, 0x05, 0x96, 0xB1, 0xD6, 0xA1, 0x3F,
0x17, 0x1F, 0x2F, 0x4D, 0x55, 0x8E, 0x11, 0x53, 0x81, 0xC7, 0xC0, 0xA6, 0x98, 0x5C, 0x45, 0x4D,
0xC6, 0xAE, 0x87, 0x3C, 0xB5, 0xBE, 0xE5, 0x25, 0x9D, 0xB0, 0x96, 0xE7, 0x09, 0x21, 0x23, 0x80,
0xCA, 0x82, 0x2E, 0x1B, 0xED, 0xDA, 0xB5, 0x2B, 0xF9, 0x32, 0x80, 0x13, 0x6D, 0x13, 0x01, 0xE8,
0x11, 0xFC, 0xB2, 0x65, 0xEB, 0x74, 0xC0, 0x8C, 0x96, 0xA4, 0x02, 0xFD, 0xEB, 0x11, 0x74, 0x65,
0x9D, 0x67, 0xF4, 0xB8, 0xDF, 0x81, 0xE8, 0x6B, 0xE7, 0x62, 0x93, 0xA7, 0xCF, 0xD2, 0x6C, 0x86,
0xA7, 0x87, 0x98, 0x96, 0xC3, 0xB3, 0x97, 0x91, 0x25, 0x52, 0x92, 0x4A, 0x80, 0x47, 0x78, 0xA0,
0x13, 0x15, 0x25, 0x82, 0x95, 0x36, 0x18, 0xF4, 0xE1, 0x79, 0xBA, 0x80, 0xF1, 0x2B, 0x64, 0xF6,
0xCA, 0x93, 0x6B, 0x29, 0x9F, 0x7E, 0xC6, 0x01, 0xCA, 0x28, 0xC0, 0xB9, 0x01, 0x5B, 0xB7, 0x50,
0x7F, 0x14, 0xDA, 0x12, 0x00, 0x1A, 0xD8, 0x5C, 0xDB, 0x60, 0xA5, 0xA7, 0xD9, 0xF4, 0x5C, 0x64,
0xC9, 0x49, 0x53, 0x76, 0x14, 0x20, 0xD8, 0xD5, 0x53, 0x70, 0x9B, 0xB0, 0xDD, 0x2E, 0xCD, 0x76,
0x95, 0x4B, 0xC4, 0xD0, 0xB5, 0x6E, 0x7B, 0x4F, 0xA9, 0x33, 0x90, 0xBF, 0xC5, 0x97, 0xEE, 0x2D,
0xF1, 0x07, 0x10, 0x9E, 0x67, 0x7C, 0xDF, 0x75, 0x80, 0x68, 0xD2, 0x91, 0x00, 0xAD, 0x8F, 0x96,
0x1A, 0x52, 0x80, 0x05, 0x7D, 0xBD, 0xC8, 0xB2, 0x94, 0xBD, 0xDE, 0xE0, 0x04, 0xF2, 0x4F, 0x4A,
0x1E, 0xFD, 0x04, 0xE8, 0xE6, 0x23, 0xFD, 0xE8, 0x64, 0x4D, 0xB7, 0xF5, 0x5B, 0x8C, 0xE6, 0x96,
0x71, 0xE0, 0xB5, 0x86, 0x4D, 0x77, 0x05, 0x76, 0x77, 0x5D, 0x51, 0x83, 0x0F, 0x8A, 0xC8, 0x01,
0xD4, 0x83, 0x17, 0x01, 0x5C, 0x9F, 0x00, 0xEA, 0x1E, 0xDA, 0xF3, 0x5C, 0x9A, 0x5B, 0x07, 0x20,
0xED, 0xD1, 0xB5, 0xD7, 0x1F, 0x01, 0x18, 0x7B, 0x21, 0xBF, 0xD9, 0xE5, 0x03, 0x5E, 0x57, 0x68,
0x2B, 0xD8, 0x06, 0xFF, 0x87, 0xE8, 0xC8, 0x1C, 0x5B, 0xEE, 0xA6, 0x18, 0xB6, 0xB4, 0x4F, 0x3F,
0x09, 0xB9, 0xF8, 0xED, 0x86, 0xC4, 0x92, 0x85, 0x4C, 0x0F, 0x64, 0xF5, 0xA6, 0x7E, 0xB4, 0xB5,
0x55, 0x1F, 0x4A, 0xD1, 0x52, 0x83, 0x63, 0xD5, 0x18, 0x55, 0xC7, 0x99, 0x17, 0x11, 0xDB, 0x55,
0x9A, 0xF7, 0x57, 0xD1, 0x94, 0xA7, 0x41, 0xDF, 0x3A, 0x3C, 0x83, 0xB5, 0xD2, 0x95, 0xC5, 0x9F,
0x17, 0xE1, 0xB5, 0x15, 0x36, 0xA2, 0x63, 0xAB, 0x5E, 0xF6, 0x90, 0xFD, 0x05, 0x59, 0x5F, 0xE2,
0xD2, 0xB6, 0xF7, 0x7D, 0x72, 0x37, 0xE8, 0x57, 0x42, 0x6B, 0xAB, 0x0C, 0xBD, 0x83, 0x68, 0x8C,
0x45, 0x17, 0x58, 0x3A, 0xEC, 0xF5, 0x35, 0x0B, 0xD1, 0x52, 0x13, 0x72, 0xC1, 0x9A, 0xEF, 0x32,
0xB1, 0xA1, 0x1B, 0x60, 0xAD, 0xD8, 0x1E, 0x6F, 0x30, 0x3A, 0x6D, 0xDD, 0x33, 0x6A, 0x63, 0xFE,
0xB0, 0xDC, 0x8C, 0xC0, 0xFE, 0x6A, 0x64, 0xB4, 0x96, 0x77, 0x25, 0xBF, 0x6E, 0xB2, 0x56, 0x62,
0xBB, 0x56, 0x3E, 0x93, 0xAF, 0x42, 0xEF, 0x2E, 0xA3, 0x47, 0xC0, 0xB3, 0x8F, 0xDD, 0x57, 0x44,
0x0C, 0xE5, 0xDE, 0x95, 0x33, 0xE5, 0x22, 0xA5, 0x39, 0x59, 0x4E, 0x96, 0x01, 0x65, 0xAD, 0xF1,
0xBA, 0x25, 0xAC, 0x01, 0x05, 0x09, 0x5B, 0x5D, 0x18, 0xAC, 0x9E, 0xD8, 0xD5, 0xAE, 0xE4, 0x28,
0x40, 0xF8, 0x18, 0xFE, 0xD6, 0x52, 0xAF, 0x21, 0xD7, 0xD2, 0xD6, 0x49, 0x2F, 0x90, 0x85, 0x1E,
0xED, 0xCC, 0xB0, 0x91, 0x09, 0x7A, 0x20, 0x1C, 0xFB, 0x23, 0xA0, 0x04, 0x3A, 0x36, 0x1A, 0xD0,
0x8D, 0x02, 0x82, 0x7A, 0x4F, 0x57, 0x94, 0xBE, 0xC6, 0xE2, 0xCB, 0x25, 0x21, 0xED, 0x1D, 0xF8,
0xDA, 0xEA, 0x26, 0x52, 0x11, 0x0C, 0x12, 0x4A, 0x9E, 0xE0, 0x11, 0xF0, 0x08, 0x78, 0x04, 0x3C,
0x02, 0x1E, 0x01, 0x8F, 0x80, 0x47, 0xC0, 0x23, 0xE0, 0x11, 0xF0, 0x08, 0x78, 0x04, 0x3C, 0x02,
0x1E, 0x01, 0x8F, 0x80, 0x47, 0xC0, 0x23, 0xE0, 0x11, 0xF0, 0x08, 0x78, 0x04, 0x3C, 0x02, 0x1E,
0x01, 0x8F, 0x80, 0x47, 0xC0, 0x23, 0xE0, 0x11, 0xF0, 0x08, 0x78, 0x04, 0x3C, 0x02, 0x1E, 0x01,
0x8F, 0x80, 0x47, 0xC0, 0x23, 0xE0, 0x11, 0xF0, 0x08, 0x78, 0x04, 0x3C, 0x02, 0x1E, 0x81, 0x62,
0x08, 0xF0, 0x68, 0xDD, 0x84, 0xF0, 0x19, 0x41, 0x3D, 0xFE, 0xF6, 0xAD, 0x62, 0x5A, 0x95, 0x4B,
0xF1, 0xF8, 0x9C, 0x1E, 0x83, 0xD6, 0xCB, 0xBC, 0xCF, 0x50, 0x46, 0xAF, 0xE3, 0xB8, 0x16, 0xE1,
0xE9, 0xDF, 0x8E, 0xC9, 0x9F, 0x17, 0x5D, 0x7A, 0x4B, 0xEB, 0xF4, 0xDD, 0x19, 0x9B, 0x33, 0xCB,
0xBC, 0x02, 0xDA, 0xD2, 0x2E, 0x76, 0x89, 0x3E, 0x7E, 0xB7, 0xE7, 0xE1, 0xDC, 0x21, 0xCC, 0xD5,
0x59, 0xE4, 0x1B, 0x18, 0xC3, 0x5C, 0xF0, 0xF9, 0x40, 0x18, 0x91, 0x5F, 0x87, 0xAF, 0xC7, 0x21,
0xCB, 0x26, 0xF4, 0xCE, 0x44, 0xAF, 0x41, 0x19, 0x5B, 0x87, 0x94, 0x15, 0x2E, 0xC8, 0xE4, 0xF1,
0xD1, 0x3E, 0xD8, 0xFB, 0xAF, 0xD0, 0x0F, 0xF9, 0xB2, 0x10, 0x6C, 0xF7, 0x2F, 0xA8, 0x5E, 0x48,
0x2C, 0x7A, 0x56, 0xB5, 0x90, 0x74, 0x01, 0x21, 0xDE, 0x40, 0xF9, 0x06, 0x4E, 0xEB, 0x65, 0x88,
0x19, 0xE4, 0xCB, 0x70, 0x5A, 0xDF, 0xBE, 0xBF, 0xA5, 0x80, 0x6A, 0x45, 0x22, 0x00, 0xFF, 0x10,
0xFD, 0x0C, 0x47, 0xF9, 0x43, 0xFA, 0x3E, 0xA3, 0x22, 0x23, 0x15, 0x2A, 0xD1, 0xB7, 0x9E, 0x99,
0x1D, 0xDF, 0xD0, 0xD0, 0x70, 0x31, 0x63, 0xDE, 0xCA, 0xB3, 0xAD, 0x13, 0xF1, 0xE1, 0x6E, 0xD7,
0x1C, 0xE3, 0x57, 0xBB, 0xE4, 0x8D, 0x1F, 0x97, 0x5F, 0x49, 0x3D, 0xEB, 0x25, 0x73, 0x02, 0xEF,
0x24, 0x1E, 0x58, 0x7E, 0x32, 0xCF, 0x26, 0xBE, 0x9A, 0xC8, 0x1A, 0x7C, 0xD6, 0x6B, 0xC1, 0xFA,
0x5F, 0x08, 0x37, 0x53, 0x5F, 0xC0, 0x93, 0xE9, 0x8B, 0x28, 0x73, 0x1F, 0xEC, 0x46, 0x47, 0xAF,
0x14, 0xE8, 0x19, 0x61, 0x3D, 0xD3, 0x9B, 0x78, 0x32, 0x5D, 0xF4, 0xA2, 0x09, 0x8C, 0x26, 0x62,
0x62, 0x1A, 0xAF, 0x9F, 0x05, 0xF1, 0x48, 0xFD, 0x1A, 0x72, 0x3D, 0xF6, 0xA7, 0x83, 0xED, 0x1B,
0xF8, 0x4B, 0x75, 0xDB, 0x57, 0x79, 0x16, 0xF8, 0xAB, 0xD0, 0x9B, 0x8A, 0xDA, 0x4D, 0x93, 0xCB,
0x75, 0x94, 0xCE, 0x82, 0x7F, 0x58, 0x91, 0xA6, 0xBC, 0x2B, 0x69, 0x0C, 0xAE, 0x96, 0xC1, 0xA5,
0xBE, 0x43, 0xA1, 0x7E, 0x01, 0x40, 0x6F, 0x17, 0xBD, 0x44, 0x79, 0x8C, 0xDA, 0x4C, 0xD8, 0x8D,
0x14, 0x89, 0xA7, 0xD2, 0xC5, 0x43, 0xE6, 0xEB, 0xE4, 0x9E, 0xD8, 0x5B, 0x42, 0x2E, 0x7C, 0xF0,
0x49, 0x9E, 0xD7, 0x89, 0xF5, 0xEE, 0x76, 0xD9, 0xC4, 0xCA, 0x74, 0x38, 0x81, 0xA6, 0xB7, 0x6A,
0x7B, 0x49, 0x10, 0xBD, 0xE8, 0x4B, 0x0C, 0xD0, 0xF4, 0x79, 0x8A, 0x22, 0x2B, 0xA6, 0xDE, 0x00,
0x18, 0x8A, 0xEE, 0x22, 0x0E, 0x9A, 0x60, 0x4C, 0x65, 0x3A, 0x5D, 0x8F, 0x5C, 0xB3, 0x27, 0x9E,
0xB9, 0xBC, 0x9E, 0x3E, 0x6E, 0x47, 0x57, 0x2F, 0x06, 0xC5, 0x5F, 0xA7, 0x48, 0xED, 0x0E, 0x8C,
0x83, 0x7F, 0xD8, 0x21, 0x26, 0x18, 0x47, 0xFF, 0xE7, 0x01, 0x7A, 0xF0, 0x5F, 0x53, 0x44, 0xCF,
0x3A, 0x00, 0xC5, 0xCB, 0x4A, 0x04, 0xB9, 0x3E, 0x2E, 0xA0, 0xB7, 0xD0, 0xF4, 0x8E, 0x8F, 0x30,
0xD3, 0x6B, 0x27, 0xE7, 0xE2, 0xD7, 0xA3, 0xAE, 0x0E, 0x2B, 0xFC, 0xC7, 0x09, 0x7A, 0xBD, 0xBA,
0x38, 0x2C, 0xA4, 0xBF, 0x45, 0x7F, 0xA3, 0xC3, 0x37, 0x86, 0x5D, 0xD1, 0x42, 0xF5, 0x66, 0xAD,
0xF0, 0x0C, 0x78, 0x2C, 0x93, 0x51, 0xF6, 0x25, 0xD1, 0x42, 0xBD, 0xB6, 0x50, 0x88, 0x95, 0xEC,
0x7C, 0x00, 0xBF, 0x1F, 0xB0, 0xA2, 0x03, 0x96, 0xB7, 0x02, 0x6E, 0xCB, 0x33, 0x8B, 0xBC, 0xFE,
0xB3, 0xCB, 0x83, 0x79, 0x72, 0xC6, 0x67, 0x12, 0xA6, 0x51, 0xCF, 0x0D, 0x78, 0xC0, 0x5F, 0x88,
0x5C, 0x6F, 0x6D, 0x13, 0x08, 0xFC, 0xF9, 0xD4, 0xCF, 0xE3, 0xBF, 0x6D, 0xCE, 0xE0, 0x95, 0xC3,
0xFF, 0xC5, 0x86, 0xDE, 0xF7, 0x29, 0x79, 0xE7, 0x87, 0x76, 0x49, 0x22, 0x10, 0x7F, 0x85, 0x5F,
0x43, 0x21, 0xAE, 0x06, 0xDF, 0x23, 0xD1, 0x89, 0x5E, 0x3D, 0x29, 0x11, 0x2C, 0xD3, 0x20, 0x80,
0xA4, 0x37, 0xA3, 0x8C, 0x88, 0x58, 0x3D, 0x42, 0x7E, 0x5B, 0xFA, 0x2C, 0x3B, 0x2E, 0xFC, 0xF8,
0x7B, 0xEC, 0xD5, 0xE7, 0xD8, 0x2B, 0xCC, 0xD6, 0x5C, 0xB1, 0x30, 0x8C, 0x01, 0x9F, 0x5B, 0x51,
0xEA, 0x27, 0x45, 0x68, 0x0A, 0xF4, 0xEF, 0xD3, 0x97, 0xBE, 0x63, 0xA3, 0x6F, 0x10, 0x24, 0x12,
0x1F, 0xAE, 0x78, 0x1B, 0xE2, 0x61, 0x62, 0xE0, 0xB3, 0x5E, 0x9A, 0x9E, 0xCC, 0x99, 0x60, 0x21,
0xE3, 0x95, 0xEE, 0xBB, 0xE4, 0xDB, 0x58, 0x94, 0x66, 0x52, 0x66, 0x2E, 0x8E, 0xD2, 0xB5, 0xD4,
0xAC, 0x80, 0x37, 0xA5, 0xDD, 0x55, 0x12, 0x50, 0x23, 0x09, 0xEC, 0xC7, 0x01, 0x4D, 0xEF, 0x37,
0x35, 0xF0, 0x8F, 0x5B, 0x3E, 0xC7, 0x60, 0x9F, 0xCA, 0xF3, 0x07, 0x70, 0xF4, 0x91, 0x87, 0x03,
0xD0, 0x79, 0x89, 0x15, 0x44, 0xDB, 0x9F, 0x5D, 0x92, 0xC2, 0xB3, 0x41, 0xE1, 0x37, 0x12, 0x99,
0xF0, 0x0E, 0x1C, 0xB8, 0xBF, 0xA5, 0x3C, 0x38, 0x74, 0xE8, 0x29, 0x7C, 0xDC, 0x20, 0xBA, 0x26,
0x17, 0x5F, 0xFF, 0x8D, 0x76, 0xA1, 0xD7, 0xA1, 0x6A, 0x6B, 0x6B, 0xEB, 0xF8, 0x90, 0x46, 0xD9,
0xC5, 0x08, 0xBB, 0xC7, 0xD3, 0x8F, 0xDE, 0x4E, 0x6C, 0x24, 0x97, 0x95, 0x85, 0xDF, 0x40, 0x6E,
0x51, 0x02, 0xF7, 0xA3, 0xF0, 0x7F, 0x0A, 0xFD, 0x1E, 0xC7, 0x78, 0x02, 0x5B, 0xB4, 0xB5, 0x5D,
0x9A, 0x45, 0x79, 0x0D, 0x81, 0xAE, 0x97, 0xF7, 0x0A, 0x27, 0xF0, 0x98, 0x8A, 0xF0, 0x54, 0xEC,
0x75, 0xC2, 0xDE, 0x97, 0x28, 0xBF, 0x48, 0xBE, 0x87, 0xFA, 0x3D, 0xE1, 0x01, 0xA0, 0x33, 0xF8,
0xCD, 0xCC, 0xC3, 0xC3, 0x61, 0x3F, 0x09, 0xDB, 0x7F, 0x35, 0x01, 0xCF, 0xC0, 0xF4, 0xF2, 0xF4,
0x4D, 0x8C, 0x40, 0xDB, 0x83, 0xC4, 0x37, 0x79, 0x12, 0x23, 0xDB, 0xC3, 0x09, 0x4C, 0xD2, 0xE9,
0xE4, 0x47, 0xD3, 0xDC, 0x64, 0x9C, 0xDF, 0x83, 0x7E, 0x16, 0xFC, 0x9B, 0xA9, 0x7F, 0x99, 0xC0,
0xF8, 0x4A, 0x9A, 0x9C, 0x4B, 0x63, 0x25, 0x7C, 0x93, 0xF6, 0x64, 0xA3, 0x29, 0x28, 0xD0, 0xFD,
0xA3, 0xDA, 0x2C, 0x0C, 0xA7, 0x72, 0x16, 0xFA, 0x1D, 0xF6, 0xB4, 0xAA, 0x2A, 0xE0, 0xB7, 0x12,
0x3C, 0x81, 0x2C, 0x34, 0xBD, 0x4F, 0xA7, 0x7F, 0xE1, 0x7D, 0x01, 0xFD, 0xE8, 0x1D, 0xE9, 0x16,
0x27, 0xFA, 0xBD, 0x85, 0x85, 0xE9, 0xCB, 0x32, 0x44, 0x7F, 0x2A, 0xF4, 0xE9, 0xB9, 0xDB, 0xB0,
0x7F, 0xBF, 0xC6, 0x44, 0xFB, 0x66, 0xE8, 0x17, 0x29, 0x48, 0x2B, 0x49, 0x1A, 0x87, 0x12, 0x36,
0xBF, 0xC3, 0x38, 0x3E, 0xAF, 0xFF, 0x5D, 0xBD, 0x79, 0xF3, 0xE6, 0xDB, 0x21, 0x9D, 0x43, 0xBF,
0x3F, 0x16, 0x9F, 0x7C, 0x06, 0xBC, 0x04, 0xBE, 0x7F, 0x15, 0x01, 0x0F, 0x38, 0xDA, 0xBA, 0xE8,
0xBF, 0x3D, 0x8D, 0xD4, 0x40, 0x95, 0xA0, 0x05, 0x17, 0x4C, 0xDB, 0x5B, 0xE5, 0xFF, 0x1A, 0x40,
0x48, 0x45, 0x17, 0x5A, 0xE5, 0x35, 0x52, 0xB9, 0xBA, 0x28, 0x0D, 0x66, 0x4F, 0x5C, 0x6C, 0x3E,
0x47, 0x31, 0x24, 0x55, 0xB2, 0x55, 0xAB, 0x5F, 0x02, 0xF6, 0xE7, 0xD2, 0x78, 0x9C, 0xA5, 0x7A,
0x32, 0x29, 0x0B, 0xF0, 0xBF, 0xBF, 0xEC, 0x91, 0xC7, 0xD0, 0xFE, 0x36, 0xB2, 0x7A, 0x91, 0x34,
0xB0, 0x8F, 0xEE, 0xD9, 0x04, 0xC3, 0x41, 0xB4, 0x5F, 0x56, 0xE0, 0x50, 0xFF, 0x12, 0x41, 0x7B,
0x0C, 0x2B, 0xD7, 0x1F, 0xD2, 0x6C, 0x8A, 0x86, 0x3F, 0xDA, 0x9F, 0x9F, 0x6D, 0x7C, 0x82, 0xAE,
0x9A, 0x76, 0x6F, 0xB5, 0xD9, 0x02, 0x64, 0x5E, 0x43, 0x20, 0xA3, 0xEB, 0x8E, 0x2E, 0xE4, 0x93,
0xB0, 0x31, 0x91, 0xF2, 0x14, 0x68, 0xFA, 0x7F, 0x71, 0x25, 0xFF, 0xA9, 0x0A, 0x7A, 0xE1, 0xA4,
0x03, 0x14, 0x5B, 0x0F, 0x52, 0x6A, 0x4B, 0x17, 0x7C, 0xED, 0xC1, 0x51, 0xBE, 0x85, 0xBA, 0x72,
0x66, 0x62, 0xBC, 0xAB, 0x61, 0xEA, 0xF5, 0xEF, 0xFB, 0xC0, 0x62, 0x7C, 0xA6, 0x60, 0xC8, 0x60,
0xEB, 0xB8, 0x8C, 0xEA, 0x98, 0x30, 0x2B, 0x36, 0x3A, 0xA2, 0x9B, 0xBA, 0x45, 0xCA, 0x0D, 0x78,
0x14, 0xF5, 0x6A, 0x74, 0x60, 0x9A, 0x52, 0x17, 0x16, 0x1F, 0x79, 0x62, 0xEF, 0x37, 0x92, 0x6D,
0xCC, 0xD3, 0x2D, 0xED, 0x18, 0xFF, 0xFF, 0x8E, 0x89, 0x68, 0xA8, 0xC4, 0x8E, 0xFE, 0xEF, 0x1D,
0x7A, 0xCF, 0x98, 0x2E, 0xB6, 0x74, 0x5A, 0x2E, 0x79, 0xC3, 0x18, 0xDE, 0x05, 0xD0, 0x75, 0xE1,
0xA9, 0xE0, 0x2D, 0x49, 0xD0, 0xBB, 0xD0, 0xF7, 0xB3, 0x8C, 0xE3, 0x08, 0x31, 0x90, 0x99, 0xC5,
0x64, 0x8E, 0x53, 0x9D, 0x09, 0x56, 0xC0, 0x97, 0x24, 0xEE, 0x6C, 0xE9, 0x02, 0x7C, 0x2F, 0x5B,
0x2D, 0xD1, 0x7B, 0x05, 0xFD, 0x87, 0xD0, 0x39, 0xA7, 0x44, 0x30, 0x6C, 0x60, 0x4F, 0xFF, 0x8F,
0x49, 0xD7, 0x12, 0x41, 0xE2, 0x40, 0xD1, 0x5B, 0xD4, 0x73, 0xC2, 0x66, 0x91, 0xE2, 0x18, 0x84,
0x66, 0x91, 0xC7, 0xD1, 0xB7, 0x5E, 0x8F, 0x6F, 0x51, 0xC2, 0xCF, 0x25, 0x2D, 0x32, 0xD0, 0x02,
0x65, 0xB0, 0x48, 0x0D, 0x76, 0x99, 0xCC, 0x0D, 0x78, 0x80, 0xD3, 0x0A, 0x10, 0x24, 0x26, 0x3D,
0x7A, 0x2D, 0xDD, 0x68, 0x1F, 0x45, 0xC9, 0xCA, 0xA6, 0x40, 0xD3, 0x2A, 0xBF, 0xC7, 0x24, 0x82,
0xE2, 0xFE, 0xB8, 0x33, 0x04, 0xAE, 0x2E, 0xAE, 0x86, 0xBA, 0x74, 0x68, 0xA7, 0xD2, 0xFE, 0x21,
0xC1, 0x6A, 0x07, 0xC1, 0x53, 0x0A, 0x5A, 0x26, 0x65, 0xFB, 0x79, 0xD9, 0x15, 0x4E, 0xA9, 0x6B,
0xB5, 0xE4, 0x94, 0xFD, 0x43, 0x4E, 0xD9, 0xFF, 0xC3, 0x41, 0xA3, 0x95, 0xFF, 0x43, 0xF6, 0xEB,
0x43, 0xC2, 0x8B, 0xB9, 0x48, 0x03, 0xB9, 0xE0, 0xF6, 0xA2, 0x11, 0x38, 0x50, 0x06, 0x22, 0x6F,
0xCD, 0xDC, 0x12, 0xD9, 0xC9, 0x8C, 0x69, 0x9E, 0x04, 0xE9, 0xE3, 0x59, 0x8A, 0xFE, 0xCC, 0xF7,
0xA7, 0xA0, 0x37, 0xFB, 0x6E, 0x90, 0x75, 0x86, 0x0F, 0x67, 0x52, 0x1F, 0x6C, 0xED, 0xA2, 0x25,
0x7D, 0xB6, 0x93, 0xEF, 0xE4, 0x43, 0xB0, 0xA1, 0x6D, 0x6C, 0x73, 0xD2, 0x52, 0xB0, 0xF8, 0x71,
0x96, 0x42, 0x6E, 0xC0, 0x33, 0x31, 0xBD, 0xD4, 0xB9, 0x12, 0xE5, 0xF2, 0x2C, 0x43, 0x9E, 0x9E,
0x44, 0x80, 0x20, 0x0F, 0x3E, 0x99, 0x06, 0x86, 0x4D, 0x60, 0x77, 0x35, 0x01, 0x75, 0x67, 0x52,
0x2A, 0x9F, 0xA2, 0xBB, 0x3D, 0xE8, 0x6B, 0x4F, 0x3E, 0x9F, 0xF2, 0x38, 0x6E, 0xD3, 0x2D, 0x66,
0x6B, 0x54, 0xB2, 0xC5, 0xA1, 0xFD, 0x59, 0x16, 0xA7, 0xEB, 0xE0, 0x1F, 0x2B, 0x8B, 0xD4, 0x13,
0x1B, 0x64, 0xFC, 0xA8, 0x82, 0x1F, 0xEF, 0x50, 0x72, 0xFA, 0x2F, 0xAA, 0xE3, 0xF0, 0xB7, 0x06,
0xFE, 0xA7, 0x68, 0x9F, 0x48, 0x7E, 0x8B, 0x85, 0xE6, 0x3D, 0xFA, 0xB4, 0x3B, 0x3B, 0x71, 0xBD,
0xDC, 0x36, 0x3E, 0x9C, 0x85, 0xD0, 0xD8, 0x5C, 0xC1, 0x6C, 0x81, 0x43, 0xB1, 0x71, 0x68, 0x36,
0x3B, 0xC9, 0x61, 0x1C, 0x73, 0xA1, 0x56, 0x1E, 0xF0, 0x28, 0x1F, 0x25, 0xB3, 0x18, 0x5A, 0x01,
0x00, 0x75, 0xAA, 0xEF, 0x09, 0x89, 0xC9, 0x99, 0xC5, 0xE4, 0x5C, 0xB8, 0x2B, 0x7C, 0x61, 0xAC,
0x25, 0x5F, 0x07, 0xAE, 0xB4, 0x0F, 0x56, 0xF2, 0x29, 0xE8, 0x2A, 0xB7, 0x38, 0xE1, 0x93, 0x22,
0xF5, 0xF8, 0x2C, 0x43, 0x6C, 0x79, 0xF6, 0x41, 0x66, 0x35, 0xFC, 0xFE, 0x1C, 0x58, 0xFA, 0xB5,
0xB4, 0x86, 0x60, 0xBD, 0x48, 0xF2, 0x35, 0x35, 0x35, 0x75, 0xAC, 0xDA, 0xBF, 0x21, 0x78, 0x86,
0xA9, 0x4D, 0xAA, 0xE6, 0x00, 0xE9, 0xA5, 0x80, 0xC6, 0xC7, 0x83, 0xD9, 0x32, 0x8E, 0x82, 0xA7,
0xDF, 0x5B, 0x74, 0x7B, 0x50, 0x5F, 0x41, 0xBE, 0x11, 0xDE, 0xF4, 0xED, 0xA2, 0x99, 0x7F, 0x73,
0xCF, 0xB8, 0xF8, 0x71, 0x1E, 0xDA, 0xCA, 0xCD, 0x4A, 0xF8, 0xAA, 0x71, 0x64, 0xEE, 0xE1, 0xF1,
0xB3, 0x1A, 0x1F, 0x1B, 0x9B, 0x65, 0x34, 0x14, 0x2E, 0xBB, 0xC2, 0x63, 0xB8, 0x2D, 0xA0, 0x0D,
0x0F, 0x65, 0x83, 0xD3, 0x5D, 0x25, 0x9D, 0xEC, 0x6A, 0x1D, 0x80, 0xCD, 0x05, 0xBF, 0x88, 0x0F,
0x1C, 0x44, 0xBA, 0x1F, 0x7E, 0x64, 0x11, 0xD9, 0x3D, 0x4D, 0x06, 0x0C, 0x7E, 0x80, 0x4F, 0xCA,
0x41, 0x22, 0x20, 0x74, 0x5F, 0x7A, 0x06, 0x63, 0x9A, 0xC2, 0x19, 0x21, 0xB8, 0x46, 0x80, 0xA6,
0xEF, 0xB5, 0x0F, 0x26, 0xD7, 0x70, 0x80, 0xAC, 0x20, 0xB0, 0x74, 0xB1, 0xAB, 0x0F, 0x76, 0x7E,
0x11, 0xDE, 0x03, 0xA1, 0x6A, 0xD1, 0x22, 0x71, 0xAA, 0x28, 0xAA, 0x48, 0xBF, 0x5F, 0x41, 0x56,
0x77, 0x6B, 0xB4, 0x90, 0x9E, 0x49, 0xFF, 0x73, 0x8A, 0xE8, 0xEA, 0x1B, 0xC6, 0x5C, 0x80, 0xFF,
0x1A, 0x9F, 0x7B, 0x93, 0x37, 0x72, 0xCD, 0x32, 0x8A, 0x03, 0x33, 0xF7, 0xB6, 0xB4, 0x6B, 0xBB,
0xE4, 0xC3, 0x6F, 0x2E, 0x43, 0x75, 0x82, 0xFD, 0x7C, 0xC0, 0x31, 0x99, 0xC7, 0xE3, 0x7C, 0xDF,
0xDE, 0x33, 0x11, 0x60, 0xCE, 0xAA, 0x09, 0xAA, 0x5B, 0x09, 0x0A, 0x6D, 0xA5, 0x26, 0xE1, 0xE5,
0x6C, 0x82, 0x4A, 0xF3, 0x18, 0x04, 0x35, 0x41, 0xB6, 0x49, 0x8B, 0x04, 0x01, 0xA3, 0x15, 0xFD,
0x12, 0xE4, 0xF4, 0x69, 0x75, 0xA6, 0x3B, 0xF9, 0x5F, 0x95, 0x77, 0xE6, 0x08, 0xB1, 0xBF, 0x2F,
0x7D, 0xBD, 0x8B, 0x4D, 0x3D, 0xC6, 0xF0, 0x3E, 0xBF, 0x98, 0xF6, 0x29, 0x1A, 0xEC, 0xF2, 0x83,
0x7F, 0x9E, 0xA0, 0x4F, 0x8D, 0xF5, 0xC1, 0xEF, 0x41, 0x34, 0xEB, 0x39, 0x68, 0x9F, 0xC4, 0x5E,
0x43, 0x73, 0xFC, 0xB6, 0x60, 0x96, 0xBD, 0x44, 0x02, 0x2C, 0x3B, 0x0A, 0x17, 0x35, 0xC7, 0xB1,
0x84, 0xA1, 0xFF, 0xE7, 0x04, 0xB6, 0x07, 0xFA, 0x17, 0xDF, 0x6B, 0x19, 0xE6, 0x18, 0x0D, 0x15,
0xDC, 0x8E, 0x65, 0x22, 0xE6, 0x50, 0x16, 0xBE, 0x75, 0xBA, 0x33, 0x20, 0x62, 0xE2, 0x47, 0xD0,
0xEF, 0x0A, 0xB2, 0x6E, 0x05, 0xEA, 0x51, 0x0B, 0x7D, 0x3A, 0xBF, 0x1B, 0xC1, 0x3D, 0x96, 0x00,
0x4B, 0xAC, 0xC8, 0x5C, 0xDC, 0x69, 0x75, 0xAF, 0x21, 0xF0, 0x0E, 0x87, 0xBF, 0x99, 0x6D, 0xCD,
0xC3, 0x8C, 0x43, 0x0F, 0xD9, 0x3D, 0x8E, 0xEF, 0xC1, 0x59, 0x13, 0x99, 0x95, 0x3A, 0x38, 0x94,
0xA9, 0xBF, 0x50, 0x89, 0x9F, 0xAC, 0xCC, 0x7F, 0x83, 0xCD, 0x97, 0xB0, 0xBF, 0x12, 0xBB, 0xBA,
0x55, 0x7A, 0x37, 0xFD, 0xEE, 0xCB, 0x6F, 0x03, 0x2B, 0x2A, 0xB1, 0x87, 0x1F, 0xAF, 0xA1, 0xDF,
0x8B, 0x8B, 0x6A, 0xDD, 0x16, 0xAE, 0x97, 0xDF, 0xD8, 0xDF, 0x44, 0xB6, 0xDD, 0x48, 0xA6, 0xD9,
0xCC, 0x2D, 0x0D, 0x03, 0xD7, 0x69, 0xA7, 0x6F, 0xA8, 0x19, 0x04, 0x7E, 0xA6, 0x95, 0xDD, 0xCC,
0xC0, 0xD7, 0xFF, 0xDE, 0x19, 0x2E, 0x30, 0x19, 0x5A, 0x39, 0x0A, 0x27, 0x9E, 0xF3, 0xE8, 0xCB,
0xAF, 0x9B, 0x0B, 0xB5, 0x7F, 0x46, 0x69, 0x3D, 0x2B, 0xCF, 0x09, 0x4C, 0xC6, 0x7C, 0x80, 0xD7,
0x3D, 0x78, 0xFD, 0x00, 0xD2, 0x80, 0x6F, 0x7F, 0x82, 0x7E, 0x1D, 0xA7, 0x5E, 0xFD, 0xF3, 0x8C,
0xD4, 0x5F, 0x4D, 0x09, 0xA6, 0x16, 0x7D, 0xC8, 0x97, 0x7E, 0xBA, 0xD3, 0xDF, 0x12, 0x26, 0x5E,
0x7E, 0x68, 0x9B, 0x30, 0x05, 0x3F, 0x6E, 0xA0, 0x6C, 0x52, 0x3B, 0x2F, 0x11, 0x78, 0xFA, 0xD2,
0xF3, 0x3E, 0xFA, 0x01, 0x47, 0xDB, 0x1F, 0x74, 0x75, 0x17, 0x29, 0x71, 0x80, 0xB8, 0x76, 0xE0,
0xD7, 0xBA, 0xED, 0x78, 0x1D, 0x2C, 0xF5, 0x43, 0xE1, 0xAD, 0xD0, 0xAF, 0x05, 0x23, 0xC4, 0x5B,
0x37, 0x91, 0xAF, 0x27, 0x50, 0x53, 0x3F, 0x06, 0x69, 0xFA, 0x8C, 0xA5, 0x3F, 0xBA, 0x86, 0x47,
0xFC, 0x1E, 0xBE, 0x89, 0x05, 0x25, 0x98, 0xFE, 0x81, 0xCA, 0x3E, 0xE8, 0x7C, 0x1E, 0x9D, 0x19,
0xD4, 0xF5, 0xD4, 0xAC, 0x9E, 0xB5, 0x39, 0x3A, 0xEB, 0x60, 0x4A, 0x0D, 0x78, 0x0C, 0x9C, 0x86,
0x01, 0x5B, 0xDD, 0xEF, 0xC5, 0xC9, 0x42, 0x7B, 0xAC, 0x12, 0x6F, 0x3E, 0xDA, 0xC6, 0xB2, 0x9D,
0xD1, 0x1D, 0x13, 0x72, 0x00, 0xE3, 0xEE, 0x58, 0xC4, 0x16, 0x18, 0x5D, 0x4D, 0x70, 0x7C, 0x4D,
0xB2, 0xE8, 0xCD, 0x00, 0xA3, 0x4B, 0x4D, 0x8F, 0xBA, 0x7E, 0xE1, 0x6B, 0xC7, 0x84, 0x0F, 0xC2,
0xDE, 0x1D, 0x04, 0xE2, 0x83, 0xC8, 0xEB, 0x76, 0x9F, 0x89, 0xB4, 0xB8, 0xE4, 0x42, 0x74, 0x3F,
0x4E, 0xF1, 0xCB, 0x65, 0x88, 0xFE, 0x3E, 0xA0, 0xD8, 0x57, 0x8F, 0xD2, 0x86, 0xBF, 0xB8, 0x56,
0x64, 0x3F, 0xFC, 0x01, 0x47, 0x77, 0x68, 0x12, 0x09, 0xFF, 0x57, 0x42, 0xEC, 0x4A, 0xD6, 0xED,
0xD4, 0xCE, 0x1C, 0xE4, 0x7A, 0x28, 0x4E, 0x69, 0x3D, 0x7E, 0x2C, 0xDE, 0x5E, 0xDD, 0xF1, 0x17,
0x4C, 0x1A, 0xF1, 0xE7, 0x5E, 0x82, 0xFD, 0x40, 0xBE, 0x1F, 0x7F, 0x5D, 0x68, 0x7B, 0x87, 0x00,
0x35, 0x6C, 0xBE, 0x0A, 0x3E, 0x03, 0x5D, 0x22, 0xED, 0xA0, 0x89, 0xBE, 0x8E, 0x92, 0xBB, 0x5C,
0x5E, 0x56, 0x9D, 0xF1, 0xCF, 0x44, 0xEF, 0x3E, 0xF0, 0xFE, 0x2E, 0xE5, 0xEC, 0xAC, 0x60, 0x97,
0x7E, 0xE6, 0xC5, 0x1E, 0x8A, 0xFA, 0x6C, 0xEC, 0x8D, 0x18, 0xBB, 0x26, 0xAB, 0xA3, 0xDD, 0x49,
0x67, 0x1B, 0x71, 0x1E, 0x3E, 0xEA, 0x16, 0x9A, 0xFE, 0x01, 0xCB, 0x55, 0x3B, 0xC3, 0x17, 0x02,
0x72, 0x22, 0xAB, 0x71, 0x5F, 0xEC, 0xEA, 0x9F, 0xA7, 0x94, 0x5D, 0x89, 0xD4, 0x9F, 0x02, 0x8C,
0x89, 0xEF, 0xC7, 0x4A, 0xF3, 0xDC, 0xCE, 0xE8, 0x7F, 0x57, 0xDB, 0x60, 0x3E, 0xCF, 0x64, 0x6C,
0x63, 0xC9, 0x5B, 0x38, 0xAB, 0x34, 0xEB, 0xEE, 0x09, 0x77, 0x72, 0x8E, 0x60, 0xAC, 0x9F, 0x74,
0x7C, 0xD4, 0x1E, 0xFC, 0xB7, 0x76, 0xD0, 0x39, 0xF4, 0xC2, 0x55, 0x02, 0x5E, 0xFF, 0xB3, 0xA5,
0xA7, 0xAB, 0x80, 0x6F, 0x2B, 0xC1, 0xBE, 0xC5, 0x3F, 0x7C, 0xB9, 0x36, 0x7D, 0xDD, 0x23, 0xE0,
0x11, 0xF0, 0x08, 0x78, 0x04, 0x3C, 0x02, 0x1E, 0x01, 0x8F, 0x80, 0x47, 0xC0, 0x23, 0xE0, 0x11,
0xF0, 0x08, 0x78, 0x04, 0x3C, 0x02, 0x1E, 0x01, 0x8F, 0x80, 0x47, 0xC0, 0x23, 0xE0, 0x11, 0xF0,
0x08, 0x78, 0x04, 0x3C, 0x02, 0x1E, 0x01, 0x8F, 0x80, 0x47, 0xC0, 0x23, 0xE0, 0x11, 0xF0, 0x08,
0x78, 0x04, 0x5A, 0x82, 0xC0, 0x5F, 0x00, 0x5C, 0x8C, 0x4C, 0x82, 0x61, 0xED, 0x03, 0x70, 0x00,
0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82};

static char gSecondPng[] =  {
0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52,
0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x46, 0x08, 0x06, 0x00, 0x00, 0x01, 0x2C, 0x99, 0x23,
0xBD, 0x00, 0x00, 0x00, 0x01, 0x73, 0x52, 0x47, 0x42, 0x00, 0xAE, 0xCE, 0x1C, 0xE9, 0x00, 0x00,
0x06, 0xF6, 0x49, 0x44, 0x41, 0x54, 0x78, 0x01, 0xED, 0x9B, 0x79, 0x88, 0x55, 0x55, 0x1C, 0xC7,
0xE7, 0xCD, 0xCE, 0x38, 0xCE, 0x4C, 0x44, 0xA4, 0xD5, 0x98, 0x93, 0x19, 0x56, 0x23, 0x8E, 0x10,
0x84, 0x15, 0x42, 0xFF, 0x44, 0xD6, 0x1F, 0x06, 0x9A, 0x2D, 0x9A, 0x21, 0x91, 0x19, 0x11, 0x54,
0xB4, 0x51, 0x44, 0xFE, 0x51, 0x91, 0x45, 0x0B, 0x46, 0x45, 0xA4, 0x7F, 0xA9, 0xD8, 0x62, 0x12,
0x2A, 0xFD, 0x11, 0x11, 0x85, 0x64, 0x0D, 0xB6, 0x9A, 0x11, 0x99, 0x94, 0x44, 0x99, 0x90, 0x61,
0xCE, 0xFE, 0xEA, 0xCD, 0x4C, 0x9F, 0xEF, 0xED, 0x9E, 0xC7, 0x9D, 0x3B, 0xEF, 0x2E, 0xE7, 0xCD,
0x7B, 0xAF, 0x61, 0x3C, 0x17, 0xCE, 0xFC, 0xCE, 0xF2, 0x5B, 0xBF, 0x67, 0x79, 0xE7, 0x9E, 0x7B,
0xA6, 0xAA, 0x6A, 0x72, 0x3D, 0x27, 0x4F, 0x9E, 0x1C, 0x4D, 0xF4, 0xA8, 0xA7, 0xA7, 0xE7, 0x58,
0x22, 0x53, 0x50, 0x53, 0x30, 0x9F, 0x28, 0x38, 0x25, 0x18, 0xFA, 0xFB, 0xFB, 0x17, 0x86, 0x03,
0xA9, 0x0E, 0x57, 0xA8, 0x9C, 0xCB, 0xE5, 0xD6, 0x84, 0xE1, 0x19, 0xC3, 0xA8, 0x46, 0x00, 0x3F,
0xE4, 0x0B, 0xDF, 0x5A, 0x48, 0x89, 0x7D, 0x5D, 0xD8, 0xA4, 0xBD, 0x86, 0x53, 0x40, 0xA2, 0xB7,
0xB7, 0xF7, 0x45, 0x01, 0x45, 0x7A, 0xC3, 0x84, 0x4B, 0x7E, 0xA3, 0xC9, 0x47, 0xD1, 0x31, 0xFD,
0x17, 0x64, 0x1A, 0x1D, 0x1D, 0xCD, 0x66, 0x32, 0x99, 0xCD, 0xA4, 0x3E, 0x9E, 0xF9, 0xF4, 0xEB,
0x53, 0xA6, 0x1D, 0x63, 0xCB, 0x4C, 0x3E, 0x35, 0x45, 0x61, 0x46, 0x49, 0x02, 0x78, 0xF6, 0xB3,
0x4F, 0x3D, 0x0F, 0x29, 0xF7, 0xA5, 0x56, 0x14, 0xC5, 0x88, 0xF2, 0x66, 0x14, 0x25, 0xAF, 0x09,
0x51, 0x0A, 0x5C, 0xBD, 0x43, 0xA0, 0x44, 0x08, 0x30, 0x43, 0x6E, 0x28, 0x5A, 0x95, 0x06, 0xB1,
0xD2, 0xE0, 0xE0, 0xE0, 0x6C, 0xA3, 0x64, 0xC2, 0x03, 0xDB, 0x28, 0xD0, 0x2C, 0x91, 0x52, 0x95,
0x99, 0xD3, 0xCF, 0x1B, 0x03, 0x56, 0x14, 0xC1, 0x4D, 0xBE, 0x02, 0x8F, 0x1A, 0x85, 0x41, 0x6A,
0xA5, 0x30, 0x28, 0x88, 0xF2, 0x3F, 0x82, 0xE5, 0x38, 0x45, 0x91, 0xCB, 0x97, 0x09, 0x17, 0x65,
0xDF, 0xB4, 0xB4, 0xB4, 0x9C, 0x61, 0x94, 0x50, 0x3E, 0x68, 0xF2, 0xD6, 0xD4, 0x28, 0x35, 0x82,
0xAC, 0x8B, 0x0B, 0x50, 0x78, 0x9F, 0x29, 0x5B, 0xD3, 0xA0, 0x42, 0x14, 0xE5, 0x48, 0x6B, 0x92,
0x94, 0xD4, 0x26, 0x31, 0xD0, 0xC3, 0xD5, 0x28, 0x5A, 0x4F, 0xD8, 0x89, 0xBC, 0x49, 0xBA, 0x5C,
0xBB, 0x43, 0xC0, 0x21, 0xE0, 0x10, 0xB0, 0x43, 0x40, 0x3F, 0x5C, 0x2C, 0x6D, 0xF7, 0x92, 0x7A,
0xB5, 0xC4, 0xB1, 0x1A, 0x3D, 0x10, 0xD4, 0x40, 0xDD, 0x46, 0xD5, 0x07, 0xEB, 0x2A, 0x9E, 0x2F,
0xE4, 0x00, 0x75, 0x87, 0x59, 0x3E, 0x1B, 0x8C, 0x83, 0x5A, 0x4A, 0xC5, 0xC7, 0xD3, 0x56, 0x8C,
0x83, 0xD6, 0xEB, 0x2F, 0xC6, 0xF6, 0xB3, 0xE3, 0x6E, 0x97, 0x31, 0x8C, 0x56, 0x81, 0x9C, 0xF7,
0xFA, 0x5A, 0x5D, 0x5D, 0xBD, 0x72, 0x64, 0x64, 0x64, 0x09, 0xD5, 0x1D, 0xB4, 0x67, 0xE1, 0xF3,
0xFC, 0x21, 0x3F, 0x42, 0x26, 0x23, 0x27, 0xE1, 0xBD, 0x9F, 0x35, 0xFF, 0x39, 0xAF, 0xA1, 0xDC,
0x7F, 0xCC, 0xFB, 0x86, 0xB1, 0x83, 0xB3, 0xAD, 0x72, 0xC2, 0x94, 0xC9, 0x8F, 0xEB, 0x62, 0xB5,
0x23, 0xF7, 0x98, 0xE1, 0x49, 0x43, 0xAD, 0x11, 0x94, 0x52, 0x8C, 0x5C, 0x0F, 0x5A, 0x8B, 0x94,
0xC7, 0xE8, 0x6A, 0x50, 0x7A, 0x92, 0xEC, 0xAC, 0xFA, 0xFA, 0xFA, 0x0E, 0xD5, 0x15, 0x7A, 0xE4,
0x5C, 0x43, 0x43, 0xC3, 0x9C, 0xC6, 0xC6, 0xC6, 0x9F, 0x0A, 0xB5, 0x97, 0xAC, 0x8E, 0x6E, 0x1A,
0xC2, 0x58, 0xB7, 0x14, 0xCA, 0xA8, 0x51, 0x4C, 0xFD, 0x83, 0x26, 0x1F, 0xA4, 0x6C, 0x32, 0xAE,
0x16, 0x9F, 0x10, 0x0E, 0xD6, 0x97, 0x2D, 0x8F, 0xA1, 0x7A, 0xA3, 0x3C, 0xE8, 0xA0, 0xA9, 0x33,
0x54, 0xE3, 0x4D, 0xED, 0xD0, 0xCD, 0xA6, 0xAE, 0xE2, 0x34, 0xE8, 0x20, 0x8E, 0x3C, 0xAB, 0xB2,
0xEF, 0xD4, 0xEF, 0x15, 0x77, 0xC6, 0x19, 0x74, 0x08, 0x38, 0x04, 0x1C, 0x02, 0x0E, 0x01, 0x87,
0x80, 0x43, 0xC0, 0x21, 0x50, 0x52, 0x04, 0x74, 0xA4, 0xC8, 0xD6, 0xAC, 0xB1, 0xA4, 0x4A, 0xD3,
0x2A, 0xC3, 0x70, 0x35, 0x1B, 0xD1, 0xAB, 0xD8, 0x62, 0xED, 0x36, 0x5B, 0xAC, 0xB0, 0xAC, 0xEA,
0xE1, 0x39, 0x33, 0x5C, 0x6F, 0x5B, 0xB6, 0xDE, 0xF2, 0xFB, 0xFB, 0x3D, 0xCF, 0x0E, 0x5B, 0xFD,
0x21, 0xD2, 0xED, 0xBC, 0x08, 0x6D, 0xB2, 0x35, 0x5C, 0x76, 0x7E, 0x1C, 0xDD, 0x0E, 0x82, 0xDF,
0x06, 0x0D, 0x51, 0xB7, 0x9E, 0xB4, 0x55, 0x75, 0x0A, 0x44, 0x08, 0x42, 0xBB, 0xE1, 0x2B, 0x7A,
0x03, 0x1B, 0x79, 0x2A, 0x1A, 0x34, 0x9C, 0x36, 0x0F, 0x9A, 0x8F, 0xC0, 0xDB, 0x13, 0xE4, 0x6F,
0x6D, 0x6D, 0xBD, 0x94, 0x21, 0x31, 0x83, 0x31, 0x79, 0x65, 0xB0, 0x3E, 0x6D, 0xDE, 0xBA, 0x8B,
0x41, 0xC3, 0x7C, 0xC6, 0xD5, 0x4B, 0x50, 0xAD, 0x29, 0xD3, 0xCD, 0x33, 0x70, 0xA4, 0x0E, 0xFA,
0x68, 0xD8, 0x38, 0xEF, 0xCC, 0x7A, 0x0B, 0xFC, 0x90, 0x7A, 0xEF, 0xA3, 0x53, 0xB8, 0x3D, 0xAE,
0x5C, 0x0C, 0x82, 0x7B, 0x50, 0xB8, 0x07, 0x67, 0xB2, 0xA4, 0x5E, 0xE5, 0x95, 0x40, 0xE8, 0x62,
0x19, 0x02, 0xC5, 0x13, 0xA2, 0xC1, 0x67, 0xFA, 0xF4, 0xE9, 0x3B, 0x54, 0x26, 0x18, 0x21, 0x5C,
0x99, 0x47, 0x63, 0x0C, 0x83, 0xF9, 0x43, 0x70, 0xCA, 0x7D, 0x94, 0x3F, 0x35, 0xD6, 0xCD, 0x18,
0x34, 0x65, 0x02, 0x58, 0xA1, 0x3A, 0x53, 0x2E, 0x2B, 0xC5, 0xD8, 0x9D, 0x32, 0xA6, 0x84, 0x53,
0xF3, 0x40, 0xD2, 0x3B, 0xDA, 0x80, 0x36, 0x18, 0xC3, 0x61, 0x07, 0x69, 0x6B, 0x32, 0x6D, 0x36,
0xB4, 0x98, 0x2E, 0xAE, 0x62, 0x3C, 0xBD, 0x82, 0x91, 0x37, 0xE9, 0xCE, 0x83, 0x18, 0xFE, 0x3E,
0x9B, 0xCD, 0x76, 0x30, 0xCE, 0xD6, 0x51, 0xCE, 0x16, 0x32, 0x4E, 0x10, 0xFB, 0x08, 0xEA, 0xAF,
0x42, 0x6D, 0x49, 0x75, 0xD6, 0x93, 0x04, 0x64, 0xDE, 0xC7, 0x91, 0xEF, 0x70, 0xCC, 0xEB, 0x2E,
0x26, 0x45, 0x23, 0x0E, 0x0C, 0xD5, 0xD5, 0xD5, 0xCD, 0x2A, 0x64, 0x0C, 0x36, 0x7D, 0x28, 0x58,
0x54, 0x53, 0x53, 0x33, 0xB3, 0x50, 0x7B, 0x49, 0xEB, 0x58, 0xD7, 0xE6, 0xAB, 0xEB, 0x64, 0x14,
0x9A, 0x5F, 0x07, 0x41, 0xE7, 0xEE, 0x28, 0x43, 0x38, 0xF7, 0x37, 0xBC, 0x7F, 0x46, 0xB5, 0x27,
0xD5, 0x5B, 0x75, 0xF1, 0xF0, 0xF0, 0x70, 0x3B, 0x5D, 0xF9, 0x38, 0x08, 0xEA, 0x48, 0x2D, 0xFF,
0x30, 0x4B, 0x5F, 0xCA, 0x17, 0x02, 0x19, 0x1C, 0x3B, 0x41, 0x30, 0x75, 0xAC, 0x85, 0xA7, 0x07,
0xAA, 0xAD, 0xB2, 0x56, 0x5D, 0x8C, 0xA1, 0xF7, 0xD0, 0xAE, 0x14, 0xFB, 0xE0, 0x94, 0xD6, 0x47,
0x1D, 0x10, 0x36, 0x21, 0x63, 0xBD, 0xF6, 0x05, 0x95, 0x5B, 0x21, 0x18, 0x14, 0x8C, 0xCA, 0xD3,
0xDD, 0x2F, 0xE0, 0xDC, 0x3F, 0xB4, 0x67, 0x27, 0xEA, 0x9C, 0x6C, 0x58, 0x21, 0x18, 0xE5, 0x94,
0x6E, 0xC0, 0xD0, 0xFD, 0xBB, 0x40, 0xEE, 0x1C, 0x66, 0x78, 0x15, 0xC3, 0x60, 0x39, 0xDD, 0xFE,
0x4E, 0x14, 0xBF, 0x4D, 0x7D, 0x49, 0x1C, 0xE4, 0xE6, 0xCD, 0x6B, 0x18, 0x15, 0x6A, 0x17, 0x80,
0xDA, 0x8F, 0x36, 0x0E, 0x38, 0x5E, 0x87, 0x80, 0x43, 0xC0, 0x21, 0xE0, 0x10, 0x70, 0x08, 0x38,
0x04, 0x1C, 0x02, 0x0E, 0x01, 0x87, 0x80, 0x43, 0xC0, 0x21, 0xE0, 0x10, 0x70, 0x08, 0x38, 0x04,
0x1C, 0x02, 0x53, 0x10, 0x01, 0x1D, 0xCB, 0x71, 0xD0, 0xB4, 0x98, 0x23, 0xBA, 0x27, 0x38, 0x6C,
0xFA, 0x8C, 0xF3, 0x9D, 0xD8, 0x03, 0x4E, 0xF8, 0xBC, 0xCB, 0x6A, 0xD0, 0x92, 0x7C, 0xC1, 0x9A,
0x28, 0xA4, 0x25, 0x39, 0x33, 0x8A, 0x73, 0x02, 0x70, 0xD6, 0x02, 0x92, 0xAE, 0x13, 0xCE, 0x25,
0x9D, 0x4F, 0x3E, 0x7F, 0xBE, 0x2E, 0x39, 0x40, 0x13, 0xF1, 0x1E, 0xDA, 0x0E, 0x73, 0x38, 0x76,
0x0B, 0x85, 0x67, 0xFC, 0xAA, 0x49, 0x4F, 0xCA, 0x0E, 0x20, 0x08, 0xE8, 0x7C, 0xF5, 0x42, 0xD2,
0x61, 0x0E, 0x8C, 0x3F, 0x20, 0xE9, 0xE2, 0xE8, 0x4D, 0xA4, 0xCB, 0x74, 0x04, 0xCF, 0xD1, 0x7B,
0x67, 0x14, 0x4A, 0xF0, 0xC0, 0x92, 0x89, 0xFD, 0xA2, 0x02, 0x4F, 0x1D, 0x27, 0xE6, 0xCB, 0xA0,
0x2B, 0xE0, 0xDD, 0xCA, 0x69, 0xE4, 0xCE, 0x28, 0x7D, 0x53, 0xA6, 0x9E, 0xE9, 0xB7, 0x5D, 0x53,
0x90, 0xD1, 0x37, 0xE6, 0x13, 0x69, 0x38, 0x40, 0xDA, 0xF7, 0x8A, 0x8F, 0x94, 0x3F, 0x09, 0x25,
0x3F, 0x6E, 0x0A, 0x03, 0x60, 0x17, 0xBC, 0x39, 0x5F, 0x67, 0x45, 0xBF, 0x07, 0x97, 0xFC, 0xE0,
0x3C, 0x0C, 0x42, 0xB1, 0x65, 0xC0, 0x58, 0xC2, 0xA8, 0xBA, 0x42, 0xF2, 0x9C, 0x73, 0x3F, 0x14,
0xA7, 0xA7, 0xB9, 0xB9, 0xF9, 0x6B, 0x46, 0x5E, 0x1B, 0x23, 0xF0, 0x57, 0x64, 0x6E, 0x13, 0xE0,
0xD0, 0x8A, 0x5C, 0x41, 0x28, 0xFB, 0x14, 0x26, 0x98, 0x23, 0x04, 0x7F, 0x6E, 0x21, 0x00, 0x08,
0xB2, 0x53, 0xA3, 0x26, 0xD4, 0x76, 0xAD, 0xFF, 0x09, 0xC6, 0xFC, 0x23, 0xE4, 0xFE, 0x34, 0xD3,
0x12, 0xF0, 0xFA, 0xD0, 0x37, 0x8B, 0x35, 0xF7, 0x2B, 0xE8, 0x02, 0xE8, 0x2F, 0xD0, 0xF3, 0x54,
0x1F, 0xD2, 0x5F, 0xD2, 0x62, 0xD9, 0x01, 0x04, 0x8C, 0xD9, 0x41, 0x8F, 0x01, 0x6C, 0x2E, 0x41,
0xFD, 0x40, 0x70, 0x90, 0xC2, 0x6B, 0x20, 0x3C, 0xAF, 0x22, 0xD3, 0x25, 0xB9, 0xDA, 0xDA, 0xDA,
0x75, 0x41, 0xF9, 0xB8, 0x3C, 0xFA, 0x50, 0x3B, 0xBA, 0x10, 0xF0, 0x0E, 0x40, 0x3B, 0x99, 0xD6,
0x02, 0xB1, 0x83, 0xFA, 0xFF, 0x2E, 0xC2, 0xC7, 0x09, 0x17, 0xD9, 0x56, 0xD1, 0x29, 0x4C, 0x30,
0xFA, 0xB7, 0xBC, 0xCF, 0xA1, 0xDE, 0x07, 0x3B, 0x68, 0x3B, 0xC1, 0x7A, 0x77, 0x07, 0x8C, 0xFF,
0x80, 0x77, 0x0F, 0x79, 0x03, 0xDA, 0xEA, 0x69, 0xD3, 0xA6, 0x7D, 0x69, 0xDA, 0xD2, 0x50, 0x81,
0xC8, 0x88, 0x5D, 0x00, 0xDD, 0xC3, 0xD4, 0xD7, 0x3D, 0xFC, 0x5C, 0x1A, 0xB9, 0x62, 0x79, 0x2A,
0x0A, 0x20, 0x60, 0xE9, 0x4A, 0x7D, 0x0B, 0xC1, 0xFD, 0xE6, 0x3B, 0x9C, 0x03, 0xC4, 0xFD, 0x8C,
0x94, 0xA3, 0x1A, 0x99, 0xE4, 0x5B, 0x69, 0x5B, 0xAE, 0x36, 0xE8, 0x06, 0x46, 0xEF, 0x16, 0x9F,
0x2F, 0x15, 0x41, 0xBF, 0xF6, 0x93, 0xFA, 0x71, 0x3A, 0x82, 0xC0, 0xD3, 0x00, 0xF9, 0x32, 0x7A,
0xFA, 0x53, 0x09, 0x17, 0xC9, 0x54, 0x11, 0x00, 0xD9, 0x1C, 0x9F, 0x45, 0x50, 0xC7, 0x01, 0xE8,
0x22, 0x02, 0xBA, 0x0E, 0xBA, 0x57, 0xFE, 0x92, 0x3F, 0xCA, 0x36, 0xA6, 0x89, 0xF2, 0xBB, 0x14,
0x0F, 0xC1, 0x73, 0x80, 0x9B, 0x04, 0xAB, 0x00, 0x2E, 0x43, 0xFD, 0xC3, 0x36, 0x31, 0x21, 0xBB,
0x94, 0x0F, 0xAB, 0x1F, 0xFB, 0x32, 0xBB, 0x90, 0xFF, 0xC4, 0x46, 0x7E, 0xD2, 0xF2, 0x6A, 0x4A,
0x6A, 0x54, 0xF8, 0x69, 0x95, 0x1C, 0x25, 0x3F, 0x6E, 0x1B, 0xA3, 0xA9, 0x0C, 0x08, 0x83, 0xA4,
0x81, 0xA1, 0xA1, 0xA1, 0x39, 0x51, 0x01, 0x69, 0x94, 0x0E, 0x0C, 0x0C, 0x9C, 0xAD, 0x44, 0xDE,
0x1B, 0x00, 0xC8, 0xDE, 0x61, 0x6C, 0x20, 0xAF, 0xFF, 0x64, 0x99, 0x1A, 0x0F, 0xC1, 0x6C, 0x56,
0x60, 0xD0, 0xAC, 0x00, 0x32, 0x51, 0x15, 0x02, 0x50, 0x6D, 0x00, 0xA2, 0x5F, 0x81, 0x1A, 0xC3,
0x97, 0x44, 0xD1, 0x7B, 0x39, 0xBA, 0xFA, 0x7D, 0x1B, 0x23, 0xEC, 0x07, 0x57, 0x26, 0xC9, 0x94,
0xBA, 0xBD, 0xAC, 0xBF, 0xC2, 0xAC, 0x41, 0x6B, 0x01, 0x6E, 0x26, 0x74, 0x29, 0xD3, 0x55, 0xD7,
0x03, 0x62, 0x1F, 0x78, 0xB4, 0xA5, 0x19, 0x8E, 0x65, 0xA2, 0x11, 0xE0, 0xE6, 0x41, 0x3E, 0x02,
0x6C, 0xEF, 0x36, 0x27, 0x72, 0x1B, 0x6C, 0xA7, 0x7C, 0x92, 0x8D, 0xB4, 0xED, 0x65, 0x05, 0x90,
0xC0, 0x04, 0xC6, 0x35, 0x69, 0x9D, 0x89, 0xE3, 0x63, 0x1D, 0xBD, 0x84, 0x7B, 0x1A, 0xAF, 0xC3,
0xD3, 0x05, 0x70, 0x1E, 0x2B, 0xFA, 0x77, 0xD0, 0x39, 0x37, 0xFA, 0x76, 0xE2, 0xC4, 0xCB, 0xD6,
0x56, 0x56, 0x00, 0x8B, 0xF5, 0x1A, 0x80, 0x74, 0x9F, 0x78, 0x31, 0xF4, 0x66, 0x92, 0x7E, 0x95,
0x4F, 0x03, 0x3C, 0x4F, 0x1D, 0x60, 0xED, 0x64, 0x7B, 0x72, 0x17, 0x6F, 0x1F, 0xC7, 0x8A, 0xD5,
0x5F, 0x4A, 0xB9, 0x49, 0x03, 0x20, 0x53, 0x5D, 0x17, 0x5A, 0xDF, 0x52, 0x70, 0x4C, 0xD1, 0x7C,
0x8C, 0x00, 0xD6, 0x4D, 0xDA, 0x02, 0x60, 0xDB, 0xA0, 0x45, 0x5D, 0x36, 0xCC, 0x2B, 0x2B, 0x43,
0xE6, 0x7F, 0x01, 0x10, 0x20, 0xB6, 0x11, 0xCB, 0x17, 0xA4, 0xE3, 0x26, 0x26, 0xA6, 0xE2, 0xDB,
0x80, 0xD8, 0xC9, 0x88, 0x6B, 0x23, 0xBF, 0x0F, 0x9E, 0xF0, 0x2B, 0x9E, 0x61, 0x75, 0xD4, 0x21,
0xE0, 0x10, 0x70, 0x08, 0x38, 0x04, 0x1C, 0x02, 0x0E, 0x01, 0x87, 0x80, 0x43, 0xC0, 0x21, 0xE0,
0x10, 0x70, 0x08, 0x9C, 0xE2, 0x08, 0xFC, 0x0B, 0x77, 0x80, 0x7B, 0xFE, 0xFD, 0xEA, 0x48, 0x7C,
0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82};
#endif

namespace android {

// ---------------------------------------------------------------------------
static bool movieTimeout = false;
static bool videoEndBeforeLauncher = false;
#ifdef MOBILE_MIGU_BOOT
static void operateOsd(const char * name, const char* val) {
    int fd = open(name, O_RDWR);
    if (fd <0 ) {
        ALOGE("cannot operateOsd");
    }
    write(fd, val, strlen(val));
    close(fd);
}
#endif

BootAnimation::BootAnimation() : Thread(false),mRotation(0)
{
    mSession = new SurfaceComposerClient();
 		mShutdown = false;
    char prop[PROPERTY_VALUE_MAX];
    if (property_get("ro.bootanimation.rotation", prop, "0") > 0) {
        int value = atoi(prop);
        if( 0 == value || 90 == value || 180 == value || 270 == value ){
            mRotation = value;
        }
    }
    initAnimInfo();
}

BootAnimation::~BootAnimation() {
}

void BootAnimation::initAnimInfo() {
    char value[PROPERTY_VALUE_MAX];
    memset(value, 0, sizeof(value));
    property_get("persist.sys.bootadv.type", value, "NULL");
    if (!strcmp("NULL", value) || !strcmp("0", value)) {
        mAnimInfo.setAnimType(AnimInfo::VIDEO_THEN_MOVIE); 
    } else if (!strcmp("1", value)) {
        mAnimInfo.setAnimType(AnimInfo::VIDEO_ONLY); 
    } else if (!strcmp("2", value)) {
        mAnimInfo.setAnimType(AnimInfo::MOVIE_ONLY); 
    }
        
}

void BootAnimation::onFirstRef() {
    status_t err = mSession->linkToComposerDeath(this);
    ALOGE_IF(err, "linkToComposerDeath failed (%s) ", strerror(-err));
    if (err == NO_ERROR) {
        run("BootAnimation", PRIORITY_DISPLAY);
    }
}

void BootAnimation::setBootVolume()
{
	int index = 11;
    if (NO_ERROR != AudioSystem::setStreamVolumeIndex(AUDIO_STREAM_MUSIC, index, AUDIO_DEVICE_OUT_DEFAULT)) {
       ALOGE("ERROR::Fail to set bootup volume!!");
    }
}

sp<SurfaceComposerClient> BootAnimation::session() const {
    return mSession;
}
void BootAnimation::isShutdown(bool shutdown)
{

    mShutdown = shutdown;

}

void BootAnimation::binderDied(const wp<IBinder>& who)
{
    // woah, surfaceflinger died!
    ALOGD("SurfaceFlinger died, exiting...");

    // calling requestExit() is not enough here because the Surface code
    // might be blocked on a condition variable that will never be updated.
    kill( getpid(), SIGKILL );
    requestExit();
}

status_t BootAnimation::initTexture(Texture* texture, AssetManager& assets,
        const char* name) {
    Asset* asset = assets.open(name, Asset::ACCESS_BUFFER);
    if (!asset)
        return NO_INIT;
    SkBitmap bitmap;
    if(mRotation != 0){
        SkBitmap origbitmap;
        SkImageDecoder::DecodeMemory(asset->getBuffer(false), asset->getLength(),
                &origbitmap, SkBitmap::kNo_Config, SkImageDecoder::kDecodePixels_Mode);
        asset->close();
        delete asset;
        // create a bitmap with rotated dimensions and draw the rotated original bitmap
        if( 90 == mRotation ){
            bitmap.setConfig(origbitmap.config(), origbitmap.height(), origbitmap.width());
            bitmap.allocPixels();
            SkCanvas canvas(bitmap);
            canvas.translate(SkIntToScalar(bitmap.width()), 0);
            canvas.rotate(SkIntToScalar(mRotation)); 
            canvas.drawBitmap(origbitmap, 0, 0, NULL);
        }else if( 180== mRotation ){
            bitmap.setConfig(origbitmap.config(), origbitmap.width(), origbitmap.height() );
            bitmap.allocPixels();
            SkCanvas canvas(bitmap);
            canvas.translate(SkIntToScalar(bitmap.width()), SkIntToScalar(bitmap.height()));
            canvas.rotate(SkIntToScalar(mRotation)); 
            canvas.drawBitmap(origbitmap, 0, 0, NULL);
        }else if( 270 == mRotation ){
            bitmap.setConfig(origbitmap.config(), origbitmap.height(), origbitmap.width());
            bitmap.allocPixels();
            SkCanvas canvas(bitmap);
            canvas.translate(0, SkIntToScalar(bitmap.height()));
            canvas.rotate(SkIntToScalar(mRotation)); 
            canvas.drawBitmap(origbitmap, 0, 0, NULL);
        }
    }else{
        SkImageDecoder::DecodeMemory(asset->getBuffer(false), asset->getLength(),
                &bitmap, SkBitmap::kNo_Config, SkImageDecoder::kDecodePixels_Mode);
        asset->close();
        delete asset;
    }

#ifndef LARGE_BOOTANIMATE
	// FileMap memory is never released until application exit.
	// Release it now as the texture is already loaded and the memory used for
	// the packed resource can be released.
	frame.map->release();
#endif
    // ensure we can call getPixels(). No need to call unlock, since the
    // bitmap will go out of scope when we return from this method.
    bitmap.lockPixels();

    const int w = bitmap.width();
    const int h = bitmap.height();
    const void* p = bitmap.getPixels();

    GLint crop[4] = { 0, h, w, -h };
    texture->w = w;
    texture->h = h;

    glGenTextures(1, &texture->name);
    glBindTexture(GL_TEXTURE_2D, texture->name);

    switch (bitmap.getConfig()) {
        case SkBitmap::kA8_Config:
            glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, w, h, 0, GL_ALPHA,
                    GL_UNSIGNED_BYTE, p);
            break;
        case SkBitmap::kARGB_4444_Config:
            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA,
                    GL_UNSIGNED_SHORT_4_4_4_4, p);
            break;
        case SkBitmap::kARGB_8888_Config:
            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA,
                    GL_UNSIGNED_BYTE, p);
            break;
        case SkBitmap::kRGB_565_Config:
            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, w, h, 0, GL_RGB,
                    GL_UNSIGNED_SHORT_5_6_5, p);
            break;
        default:
            break;
    }

    glTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_CROP_RECT_OES, crop);
    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    return NO_ERROR;
}

#ifdef MOBILE_MIGU_BOOT
status_t BootAnimation::initTexture(const char *name, Texture* texture) {
    SkBitmap bitmap;
    bool res = SkImageDecoder::DecodeFile(name, &bitmap, SkBitmap::kNo_Config, SkImageDecoder::kDecodePixels_Mode);
    ALOGD("DecodeFile %s res=%d", name, res);
    if (!res) {
        return BAD_VALUE;
    }
	if (bitmap.getConfig() == SkBitmap::kIndex8_Config) {
        ALOGD("kIndex8_Config~");
        SkBitmap rgbaBitmap;
        rgbaBitmap.setConfig(SkBitmap::kARGB_8888_Config, bitmap.width(), bitmap.height());
        rgbaBitmap.allocPixels();
        rgbaBitmap.eraseColor(0);
        rgbaBitmap.setIsOpaque(bitmap.isOpaque());

        SkCanvas canvas(rgbaBitmap);
        canvas.drawBitmap(bitmap, 0.0f, 0.0f, NULL);
        bitmap = rgbaBitmap;
    }


    // ensure we can call getPixels(). No need to call unlock, since the
    // bitmap will go out of scope when we return from this method.
    bitmap.lockPixels();

    const int w = bitmap.width();
    const int h = bitmap.height();
    const void* p = bitmap.getPixels();

    GLint crop[4] = { 0, h, w, -h };
    texture->w = w;
    texture->h = h;

    glGenTextures(1, &texture->name);
    glBindTexture(GL_TEXTURE_2D, texture->name);

    switch (bitmap.getConfig()) {
        case SkBitmap::kA8_Config:
            glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, w, h, 0, GL_ALPHA,
                    GL_UNSIGNED_BYTE, p);
            break;
        case SkBitmap::kARGB_4444_Config:
            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA,
                    GL_UNSIGNED_SHORT_4_4_4_4, p);
            break;
        case SkBitmap::kARGB_8888_Config:
            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA,
                    GL_UNSIGNED_BYTE, p);
            break;
        case SkBitmap::kRGB_565_Config:
            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, w, h, 0, GL_RGB,
                    GL_UNSIGNED_SHORT_5_6_5, p);
            break;
        default:
            break;
    }

    glTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_CROP_RECT_OES, crop);
    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    return NO_ERROR;

}
#endif

status_t BootAnimation::initTexture(void* buffer, size_t len)
{
    //StopWatch watch("blah");

    SkBitmap bitmap;
    SkMemoryStream  stream(buffer, len);
    SkImageDecoder* codec = SkImageDecoder::Factory(&stream);
    if (codec) {
        codec->setDitherImage(false);
        if(mRotation != 0){
            SkBitmap origbitmap;
            codec->decode(&stream, &origbitmap,
                    SkBitmap::kRGB_565_Config,
                    SkImageDecoder::kDecodePixels_Mode);
            // create a bitmap with rotated dimensions and draw the rotated original bitmap
            if( 90 == mRotation ){
                bitmap.setConfig(origbitmap.config(), origbitmap.height(), origbitmap.width());
                bitmap.allocPixels();
                SkCanvas canvas(bitmap);
                canvas.translate(SkIntToScalar(bitmap.width()), 0);
                canvas.rotate(SkIntToScalar(mRotation)); 
                canvas.drawBitmap(origbitmap, 0, 0, NULL);
            }else if( 180== mRotation ){
                bitmap.setConfig(origbitmap.config(), origbitmap.width(), origbitmap.height() );
                bitmap.allocPixels();
                SkCanvas canvas(bitmap);
                canvas.translate(SkIntToScalar(bitmap.width()), SkIntToScalar(bitmap.height()));
                canvas.rotate(SkIntToScalar(mRotation)); 
                canvas.drawBitmap(origbitmap, 0, 0, NULL);
            }else if( 270 == mRotation ){
                bitmap.setConfig(origbitmap.config(), origbitmap.height(), origbitmap.width());
                bitmap.allocPixels();
                SkCanvas canvas(bitmap);
                canvas.translate(0, SkIntToScalar(bitmap.height()));
                canvas.rotate(SkIntToScalar(mRotation)); 
                canvas.drawBitmap(origbitmap, 0, 0, NULL);
            }
        }else{
            codec->decode(&stream, &bitmap,
                    SkBitmap::kARGB_8888_Config,
                    SkImageDecoder::kDecodePixels_Mode);
        }
         delete codec;
    } else {
        ALOGD("codec not found!!!");
    }

#ifndef LARGE_BOOTANIMATE
	// FileMap memory is never released until application exit.
	// Release it now as the texture is already loaded and the memory used for
	// the packed resource can be released.
	frame.map->release();
#endif	
    // ensure we can call getPixels(). No need to call unlock, since the
    // bitmap will go out of scope when we return from this method.
    bitmap.lockPixels();

    const int w = bitmap.width();
    const int h = bitmap.height();
    const void* p = bitmap.getPixels();
    int skiaformat = SkBitmap::kARGB_8888_Config;
    SkBitmap *devBitmap = NULL;
    skiaformat = bitmap.getConfig();
    if ((skiaformat != SkBitmap::kARGB_8888_Config)&&(skiaformat != SkBitmap::kRGB_565_Config)) {
		devBitmap = new SkBitmap();
		SkCanvas *canvas = NULL;
		devBitmap->setConfig(SkBitmap::kARGB_8888_Config, w, h);
		devBitmap->allocPixels();
		devBitmap->eraseARGB(255, 0, 0, 0);

		canvas = new SkCanvas(*devBitmap);
		SkPaint paint;
		paint.setFilterLevel(SkPaint::kLow_FilterLevel);
		SkRect dst = SkRect::MakeXYWH(0, 0, w, h);
		SkRect src = SkRect::MakeXYWH(0, 0, w, h);
		canvas->drawBitmapRectToRect(bitmap, &src, dst, &paint);
		delete canvas;
		 p = devBitmap->getPixels();
		 skiaformat = devBitmap->getConfig();
    }
    GLint crop[4] = { 0, h, w, -h };
    int tw = 1 << (31 - __builtin_clz(w));
    int th = 1 << (31 - __builtin_clz(h));
    if (tw < w) tw <<= 1;
    if (th < h) th <<= 1;

    switch (skiaformat) {
        case SkBitmap::kARGB_8888_Config:
            if (tw != w || th != h) {
                glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, tw, th, 0, GL_RGBA,
                        GL_UNSIGNED_BYTE, 0);
                glTexSubImage2D(GL_TEXTURE_2D, 0,
                        0, 0, w, h, GL_RGBA, GL_UNSIGNED_BYTE, p);
            } else {
                glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, tw, th, 0, GL_RGBA,
                        GL_UNSIGNED_BYTE, p);
            }
            break;

        case SkBitmap::kRGB_565_Config:
            if (tw != w || th != h) {
                glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, tw, th, 0, GL_RGB,
                        GL_UNSIGNED_SHORT_5_6_5, 0);
                glTexSubImage2D(GL_TEXTURE_2D, 0,
                        0, 0, w, h, GL_RGB, GL_UNSIGNED_SHORT_5_6_5, p);
            } else {
                glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, tw, th, 0, GL_RGB,
                        GL_UNSIGNED_SHORT_5_6_5, p);
            }
            break;
        default:
            break;
    }

    glTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_CROP_RECT_OES, crop);
    if (devBitmap!=NULL) {
    	  delete devBitmap;
    }
    return NO_ERROR;
}

status_t BootAnimation::readyToRun() {
    mAssets.addDefaultAssets();
    sp<IBinder> dtoken(SurfaceComposerClient::getBuiltInDisplay(
            ISurfaceComposer::eDisplayIdMain));
    DisplayInfo dinfo;
    status_t status = SurfaceComposerClient::getDisplayInfo(dtoken, &dinfo);
    if (status)
        return -1;
    // create the native surface
    sp<SurfaceControl> control = session()->createSurface(String8("BootAnimation"),
            dinfo.w, dinfo.h, PIXEL_FORMAT_RGB_565,ISurfaceComposerClient::eOpaque);

    SurfaceComposerClient::openGlobalTransaction();
    control->setLayer(0x40000000);
    SurfaceComposerClient::closeGlobalTransaction();

    sp<Surface> s = control->getSurface();

    // initialize opengl and egl
    const EGLint attribs[] = {
            EGL_RED_SIZE,   8,
            EGL_GREEN_SIZE, 8,
            EGL_BLUE_SIZE,  8,
            EGL_DEPTH_SIZE, 0,
            EGL_NONE
    };
    EGLint w, h, dummy;
    EGLint numConfigs;
    EGLConfig config;
    EGLSurface surface;
    EGLContext context;

    EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);

    eglInitialize(display, 0, 0);
    eglChooseConfig(display, attribs, &config, 1, &numConfigs);
    surface = eglCreateWindowSurface(display, config, s.get(), NULL);
    context = eglCreateContext(display, config, NULL, NULL);
    eglQuerySurface(display, surface, EGL_WIDTH, &w);
    eglQuerySurface(display, surface, EGL_HEIGHT, &h);
    
    if (eglMakeCurrent(display, surface, surface, context) == EGL_FALSE)
        return NO_INIT;

    mDisplay = display;
    mContext = context;
    mSurface = surface;
    mWidth = w;
    mHeight = h;
    mFlingerSurfaceControl = control;
    mFlingerSurface = s;

    mAndroidAnimation = true;

    // If the device has encryption turned on or is in process 
    // of being encrypted we show the encrypted boot animation.
    char decrypt[PROPERTY_VALUE_MAX];
    property_get("vold.decrypt", decrypt, "");

    bool encryptedAnimation = atoi(decrypt) != 0 || !strcmp("trigger_restart_min_framework", decrypt);
   if(!mShutdown){
    if ((encryptedAnimation &&
            (access(SYSTEM_ENCRYPTED_BOOTANIMATION_FILE, R_OK) == 0) &&
            (mZip.open(SYSTEM_ENCRYPTED_BOOTANIMATION_FILE) == NO_ERROR)) ||

            ((access(USER_BOOTANIMATION_FILE, R_OK) == 0) &&
            (mZip.open(USER_BOOTANIMATION_FILE) == NO_ERROR)) ||

            (mHeight == 720 && ((access(SYSTEM_BOOTANIMATION_FILE_720P, R_OK) == 0) &&
            (mZip.open(SYSTEM_BOOTANIMATION_FILE_720P) == NO_ERROR))) ||

            ((access(SYSTEM_BOOTANIMATION_FILE, R_OK) == 0) &&
            (mZip.open(SYSTEM_BOOTANIMATION_FILE) == NO_ERROR))) {
        mAndroidAnimation = false;
    }
      if (mAndroidAnimation == true) {
            gUseBootAdv=0;
        }
  }else{
  	if( ((access(USER_SHUTDOWN_BOOTANIMATION_FILE, R_OK) == 0) &&
            (mZip.open(USER_SHUTDOWN_BOOTANIMATION_FILE) == NO_ERROR))||
             ((access(SYSTEM_SHUTDOWN_BOOTANIMATION_FILE, R_OK) == 0) &&
            (mZip.open(SYSTEM_SHUTDOWN_BOOTANIMATION_FILE) == NO_ERROR))){
        mAndroidAnimation=false;
        }
  	mShutdown = false;
  	}

    return NO_ERROR;
}

static void handleMovieTimout() {
    movieTimeout = true;
    return;
}


// avoid useless sleep during animation fps. which may 
// cause addtional time for booting.
static void msleepAndCheckExit(int msec) {
    char value[PROPERTY_VALUE_MAX];
    static bool bfirstpic = true;
    int lmsec = 500;
    if(bfirstpic) {
        bfirstpic = false;
    } else {
        lmsec = 300;
    }
    //ysten.zhangjunjian,20181120,for guangdong luncher time
    char buffer[PROPERTY_VALUE_MAX];
    property_get("ro.ysten.province", buffer, "master");
    if(strcmp(buffer,"CM201_guangdong")==0 || strcmp(buffer,"CM201_jiangsu")==0)
    {
      while (lmsec-- > 0) {
        property_get(EXIT_PROP_NAME, value, "0");
        int exitnow = atoi(value);
        if (exitnow) {
            ALOGD("exit, remain:%d ms, bfirstpic:%d", lmsec, bfirstpic);
            return;
        }
        usleep(1000);
      }
    } else {
        while (!gUseBootVideo && msec-- > 0) {
            usleep(1000);
        }
    }
   //end by ysten.zhangjunjian,20181120,for guangdong luncher time
}


bool BootAnimation::videoEnd() {
    char value[PROPERTY_VALUE_MAX];
    memset(value, 0, sizeof(value));
    property_get("init.svc.bootvideo", value, "NULL");
    if (!strcmp(value, "stopped"))
        return true;
    return false;
}

bool BootAnimation::launcherDisplayedNow() {
    bool displayed = false;
    char value[PROPERTY_VALUE_MAX];
    memset(value, 0, sizeof(value));
    property_get("sys.app.launcher.displayed", value, "NULL");
    if (!strcmp("1", value))
        displayed = true;
    ALOGE("launcherDisplayed:%d", displayed ? 1 : 0);
    return displayed;
}

bool BootAnimation::threadLoop()
{
    bool r;
    char proj_type[PROPERTY_VALUE_MAX];
#ifdef MOBILE_MIGU_BOOT
    //1. start a looper thread
     // check desc, if exist, then parse
    if (access(IPTV_ANIMATION_CONFIG_BASE IPTV_ANIMATION_CONFIG_FILE, R_OK) == 0
        || access(IPTV_ANIMATION_SYSTEM_BASE IPTV_ANIMATION_CONFIG_FILE, R_OK) == 0 ) {
        gUseBootVideo = false;
        gUseBootAdv	= false;
        r = iptvMovie();
    } else {
        ALOGD("no %s", IPTV_ANIMATION_CONFIG_FILE);
    }

    // TODO: check bootanim finished?
    property_get(EXIT_PROP_NAME, proj_type, "0");
    bool bExit = atoi(proj_type)!=0;
    if (!bExit) { // why do these?
#endif
        property_get("sys.proj.type", proj_type, "ott");
	//begin:add by zhanghk at 20190521:enable bootanimation.zip play according to desc.txt
	char province[PROPERTY_VALUE_MAX];
	property_get("ro.ysten.province", province, "master");
	if(strcmp(province,"CM201_zhejiang")==0){
	    proj_type[0]='o';
	    proj_type[1]='t';
	    proj_type[2]='t';
	}
	//begin:add by zhanghk at 20190521:enable bootanimation.zip play according to desc.txt
        if (!gUseBootAdv) {
            if (mAndroidAnimation) {
                r = android();
            } else {
                r = movie();
            }
        } else {
            AnimInfo::AnimType type = mAnimInfo.getAnimType();
            if (type == AnimInfo::VIDEO_THEN_MOVIE) {
            if (gVideoAnimationFlag == 0 || gVideoAnimationFlag == 0x01) {
                    property_set("ctl.start", "bootvideo");
                    usleep(10 * 1000);
                    do {
                        usleep(10 * 1000);
                    } while(!videoEnd());
                    if (launcherDisplayedNow()) {
                        videoEndBeforeLauncher = false;
                    } else {
                        videoEndBeforeLauncher = true;
                    }
                    ALOGE("Now video videoEndBeforeLauncher:%d", videoEndBeforeLauncher ? 1 : 0);
            }
                AlarmTimer timer;
                timer.setTimer(5, handleMovieTimout);
                movie();
            } else if (type == AnimInfo::VIDEO_ONLY) {
                property_set("ctl.start", "bootvideo");
                usleep(10 * 1000);
                do {
                    usleep(10 * 1000);
                } while(!videoEnd());
                checkExit();
            } else if (type == AnimInfo::MOVIE_ONLY) {
                movie();
            }
        }
        // No need to force exit anymore
        if (!strncmp(proj_type, "mobile", 6)) {
            do {
                usleep(10 * 1000);
            } while(!launcherDisplayedNow());
        }
#ifdef MOBILE_MIGU_BOOT
    }
#endif
    property_set(EXIT_PROP_NAME, "0");

    eglMakeCurrent(mDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
    eglDestroyContext(mDisplay, mContext);
    eglDestroySurface(mDisplay, mSurface);
    mFlingerSurface.clear();
    mFlingerSurfaceControl.clear();
    eglTerminate(mDisplay);
    IPCThreadState::self()->stopProcess();
    return r;
}

bool BootAnimation::android()
{
    ALOGE("android , display w:%d, h:%d", mWidth, mHeight);

    if(!gUseBootVideo)
    {
        if ((DISPLAY_EDP_WIDTH == mWidth) && (DISPLAY_EDP_HEIGHT == mHeight)){
            initTexture(&mAndroid[0], mAssets, "images/android-logo-edp-mask.png");
            initTexture(&mAndroid[1], mAssets, "images/android-logo-edp-shine.png");
        }
        else{
            initTexture(&mAndroid[0], mAssets, "images/android-logo-mask.png");
            initTexture(&mAndroid[1], mAssets, "images/android-logo-shine.png");
        }
    }
    // clear screen
    glShadeModel(GL_FLAT);
    glDisable(GL_DITHER);
    glDisable(GL_SCISSOR_TEST);
#ifdef TV_FASTBOOTING_FUNCTION
    glClearColor(0,0,0,0);
    glClear(GL_COLOR_BUFFER_BIT);
    eglSwapBuffers(mDisplay, mSurface);

    glEnable(GL_TEXTURE_2D);
    glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);

    const GLint xc = mWidth  - mAndroid[0].w;
    const GLint yc = 0;

    
    const Rect updateRect(xc, yc, xc + mAndroid[0].w, yc + mAndroid[0].h);

    glScissor(xc, yc, updateRect.width(),
            updateRect.height());
#else
    glClearColor(0,0,0,1);
    glClear(GL_COLOR_BUFFER_BIT);
    eglSwapBuffers(mDisplay, mSurface);

    glEnable(GL_TEXTURE_2D);
    glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);

    const GLint xc = (mWidth  - mAndroid[0].w) / 2;
    const GLint yc = (mHeight - mAndroid[0].h) / 2;
    const Rect updateRect(xc, yc, xc + mAndroid[0].w, yc + mAndroid[0].h);
    glScissor(updateRect.left, mHeight - updateRect.bottom, updateRect.width(),
            updateRect.height());
#endif
    // Blend state
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);

    if(!gUseBootVideo)
    {
        property_set(RUNNING_PROP_NAME,"running");
    }
    const nsecs_t startTime = systemTime();
    do {
        nsecs_t now = systemTime();
        double time = now - startTime;
        GLint x,y;
        if( 90==mRotation || 270==mRotation){
            float t = 4.0f * float(time / us2ns(16667)) / mAndroid[1].h;
            //LOGD("time=%f t=%f floorf(t)=%f", time, t, floorf(t));
            GLint offset = (t - floorf(t)) * mAndroid[1].h;
            y = yc - offset;
        }else{
            float t = 4.0f * float(time / us2ns(16667)) / mAndroid[1].w;
            GLint offset = (1 - (t - floorf(t))) * mAndroid[1].w;
            x = xc - offset;
        }

        glDisable(GL_SCISSOR_TEST);
        glClear(GL_COLOR_BUFFER_BIT);

        glEnable(GL_SCISSOR_TEST);
        glDisable(GL_BLEND);
        glBindTexture(GL_TEXTURE_2D, mAndroid[1].name);
        if( 90==mRotation || 270==mRotation){
            glDrawTexiOES(xc, y,                 0, mAndroid[1].w, mAndroid[1].h);
            glDrawTexiOES(xc, y + mAndroid[1].h, 0, mAndroid[1].w, mAndroid[1].h);
        }else{
            glDrawTexiOES(x,                 yc, 0, mAndroid[1].w, mAndroid[1].h);
            glDrawTexiOES(x + mAndroid[1].w, yc, 0, mAndroid[1].w, mAndroid[1].h);
        }
        
        glEnable(GL_BLEND);
        glBindTexture(GL_TEXTURE_2D, mAndroid[0].name);
        glDrawTexiOES(xc, yc, 0, mAndroid[0].w, mAndroid[0].h);

        EGLBoolean res = eglSwapBuffers(mDisplay, mSurface);
        if (res == EGL_FALSE)
            break;

        // 12fps: don't animate too fast to preserve CPU
        const nsecs_t sleepTime = 83333 - ns2us(systemTime() - now);
        if (sleepTime > 0) {
            //usleep(sleepTime);
            msleepAndCheckExit(sleepTime/1000);
        }
        
        checkExit();
    } while (!exitPending());

    glDeleteTextures(1, &mAndroid[0].name);
    glDeleteTextures(1, &mAndroid[1].name);
    return false;
}

#ifdef MOBILE_MIGU_BOOT
bool BootAnimation::createCountDownLayer() {
    sp<IBinder> dtoken(SurfaceComposerClient::getBuiltInDisplay(ISurfaceComposer::eDisplayIdMain));
    DisplayInfo dinfo;
    status_t status = SurfaceComposerClient::getDisplayInfo(dtoken, &dinfo);
    if (status) {
        ALOGD("Error! getDisplayInfo, status=%d", status);
        return false;
    }
    // create the native surface
    sp<SurfaceControl> control = mSession->createSurface(String8("CountDown"),dinfo.w, dinfo.h, PIXEL_FORMAT_BGRA_8888,ISurfaceComposerClient::eFXSurfaceNormal);
    SurfaceComposerClient::openGlobalTransaction();
    control->setLayer(0x40000200);
    SurfaceComposerClient::closeGlobalTransaction();

    mCountDownSurfaceControl = control;
    return true;
}


bool BootAnimation::updateCountDown(int time) {
    sp<Surface> s = mCountDownSurfaceControl->getSurface();

    ANativeWindow_Buffer outBuffer;
    Region dirtyRegion;
    Rect dirtyRect(mWidth, mHeight);
    dirtyRegion.set(dirtyRect);
    status_t statusLock = s->lock(&outBuffer, &dirtyRect);
    if (statusLock < 0) {
        ALOGE("ERROR: unable to lock surface!\n");
        return false;
    }

    SkBitmap surfaceBitmap;
    ssize_t bpr = outBuffer.stride * bytesPerPixel(outBuffer.format);
    surfaceBitmap.setConfig(SkBitmap::kARGB_8888_Config, outBuffer.width, outBuffer.height, bpr);
    surfaceBitmap.setPixels(outBuffer.bits);

    SkCanvas surfaceCanvas(surfaceBitmap);
    SkPaint paint;
    paint.setXfermodeMode(SkXfermode::kSrc_Mode);

    // clear
    SkRect rect;
    rect.set(0, 0, mWidth, 100);
    paint.setColor(SK_ColorTRANSPARENT);
    paint.setXfermodeMode(SkXfermode::kSrc_Mode);
    surfaceCanvas.drawRect(rect, paint);

    paint.setARGB(255, 198, 0, 255);
    paint.setTextSize(32);
    paint.setAntiAlias(true);
    paint.setSubpixelText(true);
    paint.setLCDRenderText(true);

    char buf[32] = {0};
    sprintf(buf, "%d", time);
    SkRect textRect;
    int textlen = paint.measureText(buf, strlen(buf), &textRect);

    static SkBitmap countdownBmp;
    static SkBitmap secondBmp;
    if (countdownBmp.width() == 0) { // first time, init it!
        SkMemoryStream  stream(gCountDownPng, sizeof(gCountDownPng));
        SkImageDecoder* codec = SkImageDecoder::Factory(&stream);
        if (codec) {
            codec->setDitherImage(false);
            int ret = codec->decode(&stream, &countdownBmp, SkBitmap::kARGB_8888_Config, SkImageDecoder::kDecodePixels_Mode);
            delete codec;
        }
    }
    if (secondBmp.width() == 0) { // first time, init it!
        SkMemoryStream  stream(gSecondPng, sizeof(gSecondPng));
        SkImageDecoder* codec = SkImageDecoder::Factory(&stream);
        if (codec) {
            codec->setDitherImage(false);
            codec->decode(&stream, &secondBmp, SkBitmap::kARGB_8888_Config, SkImageDecoder::kDecodePixels_Mode);
            delete codec;
        }
    }

    if (countdownBmp.width() == 0 || secondBmp.width() == 0) {
        ALOGD("picture decode error...");
        s->unlockAndPost();
        return false;
    }
    // draw countdownTxt:
    int tx = mWidth-textlen -countdownBmp.width() -secondBmp.width();
    surfaceCanvas.drawBitmap(countdownBmp, tx, 0, &paint);
    tx = mWidth -secondBmp.width() - 14;  // tuning for pic
    surfaceCanvas.drawBitmap(secondBmp, tx, 0, &paint);
    tx = mWidth - textlen - secondBmp.width();
    int ty = secondBmp.height()/2 + 8; // tuning for pic
    surfaceCanvas.drawText(buf, strlen(buf), tx, ty, paint);

   // ALOGD("update text at: %d %d [%d-%d]", tx, ty, secondBmp.height(), textRect.height());

    s->unlockAndPost();
    return true;
}

#define TOTAL_TIME_ACCURATE
class MyListenner: public MediaPlayerListener {
private:
	BootAnimation *mAni;
public:
	MyListenner(BootAnimation *ani) {
		mAni = ani;
	}
	
    virtual void notify(int msg, int ext1, int ext2, const Parcel *obj) {
        if (msg == PRINT_LOG_FIRST_FRMAE_SHOWN) {
            ALOGI("notify mediaplayer first picture is shown, switch osd now.");
            
			mAni->SurfaceClear();
        }
    }
};

void BootAnimation::SurfaceClear() {

	ALOGI("SurfaceClear enter.");

	int r = 0;
	do {
		ALOGI("SurfaceClear sleep wait for really first frame for 100ms");
		usleep(100*1000);
		r++;
	} while (r < 2);

	// if(mMovieSurfaceControl != NULL && mMediaPlayer != NULL) {
		sp<Surface> surface = mMovieSurfaceControl->getSurface();
		ALOGW("boot@surfaceControl Surface");
		sp<IGraphicBufferProducer> graphicBuf = surface->getIGraphicBufferProducer();

		if (graphicBuf == NULL) {
			ALOGE("Error! cannot get graphic buffer!!!");
			// TODO jump this part!
			return;
		}

		mMediaPlayer->setVideoSurfaceTexture(graphicBuf);
	//}

	property_set(RUNNING_PROP_NAME, "running");

}

void BootAnimation::handleMessage(const Message& message) {
    static Animation::IptvPart part;
    static bool isFirst = true;

    // No valid animation, exit!
    if (mIptvAnimation.iptv_parts.size() == 0 && part.duration <= 0) {
        mIptvAnimation.totalTime = -1;
        ALOGD("handleMessage %d %d", message.what, mIptvAnimation.totalTime);
        mLooper->removeMessages(this);
        mLooper->sendMessageDelayed(1000000LL, this, message); // trigger for exit condition match!

        // fix black screen when last play video, maybe use a closePlayer func
        if (part.isVideo && !isFirst) {
            // previous part gone, if open the video, close it! maybe use a closePlayer func.
            mMediaPlayer->stop();
            mMediaPlayer->setVideoSurfaceTexture(NULL);
            mMediaPlayer->disconnect();
            mMediaPlayer.clear();
        }

        return;
    }

    // for total time match the delay duration...
#ifdef TOTAL_TIME_ACCURATE
    mLooper->removeMessages(this);
    mLooper->sendMessageDelayed(1000000000LL, this, message);
#endif

    if (mIsAdvBootanim) {
        if (mIsAdvBootanim && mIptvAnimation.totalConfigTime <= 0) {
            mCountDownSurfaceControl = NULL;
        }else {
            updateCountDown(mIptvAnimation.totalConfigTime);
        }
    }

    if (part.duration <= 0) {
        Animation::IptvPart nextPart = mIptvAnimation.iptv_parts[0];
        bool clearVideoLayerLater = false;
        if (part.isVideo && !isFirst) {
            // previous part gone, if open the video, close it! maybe use a closePlayer func.
            if (nextPart.isVideo) {
                mMediaPlayer->stop();
                mMediaPlayer->setVideoSurfaceTexture(NULL);
                mMediaPlayer->disconnect();
                mMediaPlayer.clear();
                mMovieSurfaceControl = NULL; // close video layer! show image.
                clearVideoLayerLater = false;
            } else {
                clearVideoLayerLater = true;
            }
        }

        part = mIptvAnimation.iptv_parts[0];
        mIptvAnimation.iptv_parts.removeItemsAt(0, 1);
        ALOGD("pop part to show: %d %s %d %s", part.isVideo, part.path.string(), part.duration, part.codec.string());

        // new part, check how to handle it!
        if (part.isVideo) { // maybe use a starPlayer func
            sp<IBinder> dtoken(SurfaceComposerClient::getBuiltInDisplay(ISurfaceComposer::eDisplayIdMain));
            sp<SurfaceControl> control = mSession->createSurface(String8("BootMovie"),mWidth, mHeight, PIXEL_FORMAT_RGB_565,ISurfaceComposerClient::eOpaque);
            SurfaceComposerClient::openGlobalTransaction();
            control->setLayer(0x40000010);
            SurfaceComposerClient::closeGlobalTransaction();
/*
            sp<Surface> surface = control->getSurface();
            ALOGW("boot@surfaceControl Surface");
            sp<IGraphicBufferProducer> graphicBuf = surface->getIGraphicBufferProducer();

            if (graphicBuf == NULL) {
                ALOGE("Error! cannot get graphic buffer!!!");
                // TODO jump this part!
                return;
            }
*/
            mMediaPlayer = new MediaPlayer();

            if (mMediaPlayer->setDataSource(part.path.string(), NULL) == NO_ERROR) {
                // mMediaPlayer->setVideoSurfaceTexture(graphicBuf);
                sp<MediaPlayerListener> gLstn = new MyListenner(this);
                mMediaPlayer->setAudioStreamType(AUDIO_STREAM_MUSIC);
                mMediaPlayer->setListener(gLstn);
                ALOGW("boot@MediaPlayer prepare");
                mMediaPlayer->prepare();
            }
            mMediaPlayer->start();
            mMovieSurfaceControl = control;
        } else {
            Texture tex;
            if (initTexture(part.path.string(), &tex) != NO_ERROR) {
                // jump this!
                mIptvAnimation.totalTime -= part.duration;
                part.duration = 0;
                mLooper->removeMessages(this);
                mLooper->sendMessageDelayed(10000000LL, this, message);
                return;
            }
            glBindTexture(GL_TEXTURE_2D, tex.name);
            glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
            glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

            glDrawTexiOES(0, 0, 0, mWidth, mHeight);
            eglSwapBuffers(mDisplay, mSurface);
            property_set(RUNNING_PROP_NAME, "running");
            glDeleteTextures(1, &tex.name);
            if (clearVideoLayerLater == true) {
                // previous part gone, if open the video, close it! maybe use a closePlayer func.
                mMediaPlayer->stop();
                mMediaPlayer->setVideoSurfaceTexture(NULL);
                mMediaPlayer->disconnect();
                mMediaPlayer.clear();
                mMovieSurfaceControl = NULL;// close video layer! show image.
            }
        }
    }

    // for each part match the delay duration.
#ifndef TOTAL_TIME_ACCURATE
    mLooper->removeMessages(this);
    mLooper->sendMessageDelayed(1000000000LL, this, message);
#endif

    part.duration --;
    mIptvAnimation.totalTime--;
    mIptvAnimation.totalConfigTime--;
    isFirst = false;
}

bool BootAnimation::initConfigFile(const char * conf_file, const char * base, Animation *anim) {
    char line[128] = {0,0};
    char fpath[256]={0};
    FILE *fp = NULL;
    Animation animation;

    sprintf(fpath, "%s%s", base, conf_file);
    fp = fopen(fpath, "r");
    if (fp == NULL) {
        ALOGE("invalid config file: %s, cannot open!", fpath);
        return false;
    }

    animation.totalTime = 0;
    while ( fgets(line, 128, fp) != NULL) {
        ALOGD("%s", line);
        char animType;
        char path[256]={0};
        int duration;
        char codec[32]={0};
        char *space=",";
        char *token;
        char *type;

        Animation::IptvPart part;
        // video?picture
        type = strtok(line, space);
        if (type == NULL) continue;
        part.isVideo = (strcmp(type,"v") == 0);

        // file path
        token = strtok(NULL, space);
        if (token == NULL) continue;
        sprintf(fpath, "%s%s", base, token);
        if (access(fpath, R_OK) != 0) {
            ALOGE("here access %s, ignore!", path);
            continue;
        }
        part.path = fpath;
        // duration
        token = strtok(NULL, space);
        if (token == NULL || atoi(token) <= 0 ) continue;
        part.duration = atoi(token);
        // codec
        token = strtok(NULL, space);
        if (token == NULL) continue;
        part.codec = token;

        //config file error exit
        if ((!part.isVideo && (!strncmp("mp4", part.codec, 3) || (!strncmp("ts", part.codec, 2)))) ||
            (part.isVideo && (!strncmp("jpg", part.codec, 3) || !strncmp("png", part.codec, 3)||
               !strncmp("bmp", part.codec,3)))) {
               ALOGD("config file error!");
               continue;
        }

        animation.iptv_parts.add(part);
        animation.totalTime += part.duration;
    }
    fclose(fp);

    if (animation.iptv_parts.size() > 0) {
        *anim = animation;
        return true;
    }
    return false;
}
bool BootAnimation::iptvMovie() {

    ALOGD("clear screen...");
    if (initConfigFile(IPTV_ANIMATION_CONFIG_FILE, IPTV_ANIMATION_CONFIG_BASE, &mIptvAnimation)) {
        mIsAdvBootanim = true;
        Animation mIptvAnimationDefault;
        if (initConfigFile(IPTV_ANIMATION_CONFIG_FILE, IPTV_ANIMATION_SYSTEM_BASE, &mIptvAnimationDefault)) {
            ALOGD("No default iptv bootanim...");
            mIptvAnimation.totalConfigTime = mIptvAnimation.totalTime;
            for (int i = 0; i < mIptvAnimationDefault.iptv_parts.size(); i++) {
                mIptvAnimation.iptv_parts.add(mIptvAnimationDefault.iptv_parts[i]);
                mIptvAnimation.totalTime += mIptvAnimationDefault.iptv_parts[i].duration;
            }
        } else {
           mIptvAnimation.totalConfigTime = mIptvAnimation.totalTime;
        }
    } else {
        mIsAdvBootanim = false;
        if (!initConfigFile(IPTV_ANIMATION_CONFIG_FILE, IPTV_ANIMATION_SYSTEM_BASE, &mIptvAnimation)) {
            ALOGD("No iptv bootanim...");
            return false;
        } else {
            mIptvAnimation.totalConfigTime = mIptvAnimation.totalTime;
        }
    }
    // TODO wait for AudioService UP
    if (mIptvAnimation.iptv_parts.size() > 0) {
        ALOGD("find config res");
        Animation::IptvPart part = mIptvAnimation.iptv_parts[0];
        int beforVideoShowTime = 0;
        for (int i = 0; i < mIptvAnimation.iptv_parts.size(); i++) {
            part = mIptvAnimation.iptv_parts[i];
            if (part.isVideo) {
                break;
            } else {
               beforVideoShowTime += part.duration;
            }
        }
        ALOGD("beforVideoShowTime: %d",beforVideoShowTime);
        if (beforVideoShowTime < 3) {
            usleep(15*100*1000);
        }
    }

    // clear screen
    glShadeModel(GL_FLAT);
    glDisable(GL_DITHER);
    glDisable(GL_SCISSOR_TEST);
    glDisable(GL_BLEND);
    glClearColor(0, 0, 0, 1);
    glClear(GL_COLOR_BUFFER_BIT);
    eglSwapBuffers(mDisplay, mSurface);

    glBindTexture(GL_TEXTURE_2D, 0);
    glEnable(GL_TEXTURE_2D);
    glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

    // TODO Create countdown layer, only for show advertise time...
    if (mIsAdvBootanim) {
        createCountDownLayer();
        updateCountDown(mIptvAnimation.totalConfigTime);
    }

    // animating...
    ALOGD("start Animation...");


    // A looper, hope better accurate counterdown impl
    int sockets[2];
    if (socketpair(AF_UNIX, SOCK_SEQPACKET, 0, sockets) == 0) {
        int size = 4 * 1024; // 4K socket buffer
        setsockopt(sockets[0], SOL_SOCKET, SO_SNDBUF, &size, sizeof(size));
        setsockopt(sockets[0], SOL_SOCKET, SO_RCVBUF, &size, sizeof(size));
        setsockopt(sockets[1], SOL_SOCKET, SO_SNDBUF, &size, sizeof(size));
        setsockopt(sockets[1], SOL_SOCKET, SO_RCVBUF, &size, sizeof(size));
        fcntl(sockets[0], F_SETFL, O_NONBLOCK);// receive FD
        fcntl(sockets[1], F_SETFL, O_NONBLOCK);
    } else {
        ALOGE(" pipe creation failed (%s)", strerror(errno));
        return false;
    }

    mLooper = new Looper(false);
    mLooper->addFd(sockets[0], 0, ALOOPER_EVENT_INPUT, NULL, NULL);
    if (mLooper == NULL) return false;
    // here loop for messages!
    //trigger to start loop
    Message msg;
    msg.what = 0;
    mLooper->sendMessage(this, msg);
    do {
        int32_t ret = mLooper->pollOnce(-1);
        switch (ret) {
            case ALOOPER_POLL_WAKE:
                ALOGD("ALOOPER_POLL_WAKE\n");
                break;
            default:
                ALOGD("pollOnce %d leftTime:%d leftConfigTime:%d\n", ret, mIptvAnimation.totalTime,mIptvAnimation.totalConfigTime);
                break;
        }
       if (mIptvAnimation.totalConfigTime < 0) {
            ALOGD("totalConfigTime checkExit\n");
            char value[PROPERTY_VALUE_MAX];
            property_get(EXIT_PROP_NAME, value, "0");
            int exitnow = atoi(value);
            if (exitnow) {
                ALOGE("iptvMovie Now enter exitnow !!!!");
                mIptvAnimation.totalTime = -1;
                requestExit();
            }
        }
    }while(mIptvAnimation.totalTime >= 0);
    // Close count down Surfaces
    //usleep(1000000LL); // last 1 sec sleeps here
    if (mIsAdvBootanim) {
        mCountDownSurfaceControl = NULL;
    }

    do {
        usleep(10*1000);
        checkExit();
    } while (!exitPending());

    return true;
}
#endif

void BootAnimation::checkExit() {
    // Allow surface flinger to gracefully request shutdown
    char value[PROPERTY_VALUE_MAX];
    property_get(EXIT_PROP_NAME, value, "0");
    int exitnow = atoi(value);
    if(gUseBootVideo){
        do{
            usleep(10*1000);
            memset(value,0,sizeof(value));
            property_get(EXIT_PROP_NAME, value, "0"); 
            exitnow = atoi(value);
#ifdef MOBILE_MIGU_BOOT
            if(launcherDisplayedNow()) {
                exitnow = 1;
            }
            ALOGE("Now enter : %d", exitnow);
#endif
          }while(!exitnow);
    }
    if (exitnow) {
        ALOGE("Now enter exitnow !!!!");
        if (gUseBootVideo) {
            property_set("service.bootvideo.exit", "1");
            do {
                usleep(10 * 1000);
                memset(value, 0, sizeof(value)); 
                property_get("init.svc.bootvideo", value, "NULL");
                ALOGE("Now init.svc.bootvideo:%s", value);
            } while(!strcmp(value,"running"));
        } else if (gUseBootAdv) {
            if (mAnimInfo.getAnimType() == AnimInfo::VIDEO_THEN_MOVIE) {
                if (videoEndBeforeLauncher && launcherDisplayedNow()) {
                    requestExit();
                } 
                if (!movieTimeout)
                    return;
            } else if (mAnimInfo.getAnimType() == AnimInfo::VIDEO_ONLY) {
                do {
                    usleep(10 * 1000);
                    memset(value, 0, sizeof(value)); 
                    property_get("init.svc.bootvideo", value, "NULL");
                    ALOGE("Now init.svc.bootvideo:%s", value);
                } while(!strcmp(value,"running"));
                property_set("service.bootvideo.exit", "1");
            }
        }
        ALOGE("Now before requestExit()!!!!");
        requestExit();
    }
    ALOGE("exitnow is 0 !!!!!!!!!");
}

void BootAnimation::checkOnePartExit() {
    if (!videoEndBeforeLauncher && launcherDisplayedNow())
        requestExit();
}

bool BootAnimation::movie()
{
    ZipFileRO& zip(mZip);

    size_t numEntries = zip.getNumEntries();
    ZipEntryRO desc = zip.findEntryByName("desc.txt");
    String8 rpath_m = String8("");
    if (!desc && (numEntries != -1)) {
       for (size_t i=0 ; i<numEntries ; i++) {
          char name_m[256];
          ZipEntryRO entry_m = zip.findEntryByIndex(i);
          if (zip.getEntryFileName(entry_m, name_m, 256) == 0 && !strcmp(basename(name_m), "desc.txt")) {
             desc = entry_m;
             rpath_m = String8(dirname(name_m)) + String8("/");
             ALOGE("ENTERN rpath_m %s\n", rpath_m.string());
             break;
          }
       }
    }
	
    int switch_logo_flag = 0;
    if (!desc || (numEntries == 1) || (numEntries == -1)) {
        if (switch_logo_flag == 0) {
          if (!gUseBootVideo) {
              property_set(RUNNING_PROP_NAME,"running");
          }
          switch_logo_flag = 1;
          return false;
        }
    }
    //end here
    int method;	
    size_t UncompLen;
    size_t CompLen;
    Animation animation;
    zip.getEntryInfo(desc, &method, &UncompLen, &CompLen, 0, 0, 0);
    char outBuf[UncompLen];
    char proj_type[PROPERTY_VALUE_MAX];
    property_get("sys.proj.type", proj_type, "ott");
    //begin:add by zhanghk at 20190521:enable bootanimation.zip play according to desc.txt
    char province[PROPERTY_VALUE_MAX];
    property_get("ro.ysten.province", province, "master");
    if(strcmp(province,"CM201_zhejiang")==0){
        proj_type[0]='o';
        proj_type[1]='t';
        proj_type[2]='t';
    }
    //begin:add by zhanghk at 20190521:enable bootanimation.zip play according to desc.txt
	
    char uimode[PROPERTY_VALUE_MAX];
    property_get("ubootenv.var.uimode", uimode, "0");

    if(method == ZipFileRO::kCompressStored){
         ALOGE("ENTERN ZipFileRO: kCompressStored");
         FileMap* descMap = zip.createEntryFileMap(desc);
         ALOGE_IF(!descMap, "descMap is null");
         if (!descMap) {
            return false;
         }

         String8 desString((char const*)descMap->getDataPtr(),
                 descMap->getDataLength());
         char const* s = desString.string();
         ALOGE("Stored s : %s\n",s);	

         // Parse the description file
         for (;;) {
             const char* endl = strstr(s, "\n");
             if (!endl) break;
             String8 line(s, endl - s);
             const char* l = line.string();
             int fps, width, height, count, pause;
             char path[256];
             char pathType;
             if (sscanf(l, "%d %d %d", &width, &height, &fps) == 3) {
                if(!strncmp(uimode,"1080p",5)){
                     if (width == 1280 && height == 720){
                           width = 1920;
                           height= 1080;
                           ALOGI("rejuage width & height to 1080p");
                     }
                }else if(!strncmp(uimode,"720p",4)){
                     if (width == 1920 && height == 1080){
                           width = 1280;
                           height= 720;
                           ALOGI("rejuage width & height to 720p");
                     }
                } else if(!strncmp(uimode,"576p",4)){
                     width = 720;
                     height= 576;
                     ALOGI("rejuage width & height to 576p");
                }
                //LOGD("> w=%d, h=%d, fps=%d", width, height, fps);
                if( 90==mRotation || 270==mRotation){
                    animation.width = height;
                    animation.height = width;
                }else{
                    animation.width = width;
                    animation.height = height;
                }
                animation.fps = fps;
             }else if (sscanf(l, " %c %d %d %s", &pathType, &count, &pause, path) == 4) {
                //LOGD("> type=%c, count=%d, pause=%d, path=%s", pathType, count, pause, path);
                Animation::Part part;
                part.playUntilComplete = pathType == 'c';
                part.count = count;
                part.pause = pause;
                part.path = rpath_m + path;
                animation.parts.add(part);
             }
             s = ++endl;
         }
	}else if(method == ZipFileRO::kCompressDeflated){
		ALOGE("ENTERN ZipFileRO: kCompressDeflated");
		if (true == zip.uncompressEntry(desc,  outBuf)){
		    ALOGE("uncompressEntry UncompLen : %d\n",UncompLen);	
		}
		char * s = (char *)malloc(UncompLen+1);
		memset(s, 0, UncompLen+1);
		memcpy(s, outBuf, UncompLen);
		for (;;) {
			 char* endl = strstr(s, "\n");
			if (!endl) break;
			String8 line(s, endl - s);
			const char* l = line.string();
			int fps, width, height, count, pause;
			char path[256];
			char pathType;
			if (sscanf(l, "%d %d %d", &width, &height, &fps) == 3) {
                if(!strncmp(uimode,"1080p",5)){
                    if (width == 1280 && height == 720){
                        width = 1920;
                        height= 1080;
                        ALOGI("rejuage width & height to 1080p");
                    }
                }else if(!strncmp(uimode,"720p",4)){
                    if (width == 1920 && height == 1080){
                        width = 1280;
                        height= 720;
                        ALOGI("rejuage width & height to 720p");
                    }
                }else if(!strncmp(uimode,"576p",4)){
                    width = 720;
                    height= 576;
                }
				if( 90==mRotation || 270==mRotation){
					animation.width = height;
					animation.height = width;
				}else{
					animation.width = width;
					animation.height = height;
				}
				animation.fps = fps;
			}
			else if (sscanf(l, " %c %d %d %s", &pathType, &count, &pause, path) == 4) {
				Animation::Part part;
				part.playUntilComplete = pathType == 'c';
				part.count = count;
				part.pause = pause;
				part.path = rpath_m + path;
				animation.parts.add(part);
			}
			s = ++endl;
		}	
    }

    // read all the data structures
    const size_t pcount = animation.parts.size();
    for (size_t i=0 ; i<numEntries ; i++) {
        char name[256];
        ZipEntryRO entry = zip.findEntryByIndex(i);
        if (zip.getEntryFileName(entry, name, 256) == 0) {
            const String8 entryName(name);
            const String8 path(entryName.getPathDir());
            const String8 leaf(entryName.getPathLeaf());
            if (leaf.size() > 0) {
                for (int j=0 ; j<pcount ; j++) {
                    if (path == animation.parts[j].path) {
                        int method;
                        size_t UncompLen2;
                        size_t CompLen2;
                        // supports only stored png files
                        if (zip.getEntryInfo(entry, &method, &UncompLen2, &CompLen2, 0, 0, 0)) {
                            if (method == ZipFileRO::kCompressStored) {
                                FileMap* map = zip.createEntryFileMap(entry);
                                if (map) {
                                    Animation::Frame frame;
                                    frame.name = leaf;
                                    frame.map = map;
                                    Animation::Part& part(animation.parts.editItemAt(j));
                                    part.frames.add(frame);
                                }
                            }else if(method == ZipFileRO::kCompressDeflated){
                                ALOGE("This is CompressDeflated entry\n");
                                if (UncompLen2 > 999999)
                                    continue;
                                char outBuf2[UncompLen2];
                                if (true == zip.uncompressEntry(entry, outBuf2)){
                                     Animation::Frame frame;
                                     frame.name = leaf;
                                     frame.pbuf = (char*)malloc(UncompLen2);
                                     memcpy(frame.pbuf , outBuf2, UncompLen2);
                                     frame.psize = UncompLen2;
                                     Animation::Part& part(animation.parts.editItemAt(j));
                                     part.frames.add(frame);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    // clear screen
    glShadeModel(GL_FLAT);
    glDisable(GL_DITHER);
    glDisable(GL_SCISSOR_TEST);
    glDisable(GL_BLEND);
    glClearColor(0,0,0,1);
    glClear(GL_COLOR_BUFFER_BIT);

    eglSwapBuffers(mDisplay, mSurface);

    glBindTexture(GL_TEXTURE_2D, 0);
    glEnable(GL_TEXTURE_2D);
    glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    int xc, yc;
    if(gUseBootVideo){
        animation.width=0;
        animation.height=0;
    }
    if( 90==mRotation || 270==mRotation){
        xc = ((mHeight - animation.height) / 2);
        yc = ((mWidth - animation.width) / 2);
    }else{
        xc = (mWidth - animation.width) / 2;
        yc = ((mHeight - animation.height) / 2);
    }

    nsecs_t lastFrame = systemTime();
    nsecs_t frameDuration = s2ns(1) / animation.fps;

    Region clearReg(Rect(mWidth, mHeight));
    clearReg.subtractSelf(Rect(xc, yc, xc+animation.width, yc+animation.height));

     size_t fcount_temp = 0;
	
    for (int i=0 ; i<pcount ; i++) {
        const Animation::Part& part(animation.parts[i]);
        const size_t fcount = part.frames.size();
          if (fcount == 0) {
              fcount_temp++;
              continue;
          }
        glBindTexture(GL_TEXTURE_2D, 0);

        for (int r=0 ; !part.count || r<part.count ; r++) {
            // Exit any non playuntil complete parts immediately
            if(exitPending() && !part.playUntilComplete)
                break;

            for (int j=0 ; j<fcount && (!exitPending() || part.playUntilComplete) ; j++) {
                const Animation::Frame& frame(part.frames[j]);
                nsecs_t lastFrame = systemTime();

#ifndef LARGE_BOOTANIMATE
                if (r > 0) {
                    glBindTexture(GL_TEXTURE_2D, frame.tid);
                } else {
#endif                
                    if (part.count != 1) {
                        glGenTextures(1, &frame.tid);
                        glBindTexture(GL_TEXTURE_2D, frame.tid);
                        glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
                        glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
                    }
                    if(method == ZipFileRO::kCompressStored){
                        initTexture(
                                frame.map->getDataPtr(),
                                frame.map->getDataLength());
                    }else if(method == ZipFileRO::kCompressDeflated){
                        initTexture(frame.pbuf, frame.psize);
                    }
#ifndef LARGE_BOOTANIMATE					
                }
#endif
                if (!clearReg.isEmpty()) {
                    Region::const_iterator head(clearReg.begin());
                    Region::const_iterator tail(clearReg.end());
                    glEnable(GL_SCISSOR_TEST);
                    while (head != tail) {
                        const Rect& r(*head++);
                        glScissor(r.left, mHeight - r.bottom,
                                r.width(), r.height());
                        glClear(GL_COLOR_BUFFER_BIT);
                    }
                    glDisable(GL_SCISSOR_TEST);
                }
                glDrawTexiOES(xc, yc, 0, animation.width, animation.height);
                eglSwapBuffers(mDisplay, mSurface);

                nsecs_t now = systemTime();
                nsecs_t delay = frameDuration - (now - lastFrame);
                //ALOGD("%lld, %lld", ns2ms(now - lastFrame), ns2ms(delay));
                lastFrame = now;

                if(!strncmp(proj_type, "mobile", 6)) {
                    if (delay > 0) {
                        struct timespec spec;
                        spec.tv_sec  = (now + delay) / 1000000000;
                        spec.tv_nsec = (now + delay) % 1000000000;
                        int err;
                        //do {
                            //err = clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &spec, NULL);
                        //} while (err<0 && errno == EINTR);
                    }
                } else { // save bootup time!
                    nsecs_t hundredUsDelay = delay/100000;
                    while (hundredUsDelay-- > 0) {
                        char value[PROPERTY_VALUE_MAX];
                        property_get(EXIT_PROP_NAME, value, "0");
                        int exitnow = atoi(value);
                        if (exitnow) {
                            ALOGD("requested exit, quick exit now! %ld", hundredUsDelay);
                            break;
                        }

                        usleep(100);
                    }
                }
                if (switch_logo_flag == 0){
                    if(!gUseBootVideo)
                    {
                        property_set(RUNNING_PROP_NAME,"running");
                    }
                    switch_logo_flag = 1;
                }
                /*begin:add by zhanghk at 20191016:solve white screen problem*/
                char province[PROPERTY_VALUE_MAX];
                property_get("ro.ysten.province", province, "master");
                if(strcmp(province,"CM201_jiangsu")){
                    if(!strncmp(proj_type, "mobile", 6)) {
                        if(i < (pcount-1)){
                            ALOGD("The last frame isn't shown,break!!");
                            break;
                        }
                    }
                }
                /*end:add by zhanghk at 20191016:solve white screen problem*/
#ifdef LARGE_BOOTANIMATE
                glDeleteTextures(1, &frame.tid);

#endif		    
                checkExit();
            }
            if (gUseBootAdv && i == 0) {
                checkOnePartExit();
            }

            msleepAndCheckExit(part.pause * ns2ms(frameDuration));
            //usleep(part.pause * ns2us(frameDuration));
            // For infinite parts, we've now played them at least once, so perhaps exit
            if(exitPending() && !part.count)
                break;
        }

#ifndef LARGE_BOOTANIMATE
        // free the textures for this part
        if (part.count != 1) {
            for (int j=0 ; j<fcount ; j++) {
                const Animation::Frame& frame(part.frames[j]);
                glDeleteTextures(1, &frame.tid);
                if(method == ZipFileRO::kCompressDeflated && frame.pbuf != NULL){
                     free(frame.pbuf);
                }
            }
        }
#endif	
    }
    if (fcount_temp == pcount) {
        if (switch_logo_flag == 0) {
            ALOGD("------------aa---RUNNING_PROP_NAME--------");
            property_set(RUNNING_PROP_NAME,"running");
            switch_logo_flag = 1;
        }	
    }
    /*add by zhaolianghua for jiangxi delay start launcher @20190117*/
    property_set("sys.ysten.bootanim.exit","1");
    /*add end*/
    return false;
}

// ---------------------------------------------------------------------------

}
; // namespace android
